<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speak the Sentences</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f3f8;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }
        .activity-container {
            width: 90%;
            max-width: 700px;
            padding: 30px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        #sentence-display {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
            margin-bottom: 30px;
            min-height: 50px;
            transition: color 0.3s;
        }
        #sentence-display.speakable {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }
        #sentence-display.speakable:hover {
            color: #0056b3;
        }
        #record-button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            font-size: 2.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
        }
        #record-button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        #record-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #record-button.listening {
            background-color: #dc3545;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        .feedback-area {
            margin-top: 30px;
            min-height: 80px;
        }
        #user-transcription {
            font-size: 1.2em;
            margin-bottom: 10px;
            line-height: 1.6;
        }
        #feedback-message {
            font-size: 1.5em;
            font-weight: bold;
        }
        #feedback-message.correct { color: #28a745; }
        #feedback-message.incorrect { color: #dc3545; }
        #feedback-message.suspicious { color: #ff9800; }
        .navigation-buttons button {
            background-color: #f9f9f9;
            color: #000000;
            border: 2px solid #ccc;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 5px 0;
        }
        .navigation-buttons button:hover {
            background-color: #e9e9e9;
        }
        .hide {
            display: none;
        }

        .word-feedback.correct {
            color: #28a745;
            font-style: italic;
        }
        .word-feedback.incorrect {
            color: #dc3545;
            font-weight: bold;
            text-decoration: underline;
            cursor: help;
        }
        .word-feedback.suspicious {
            color: #ff9800;
            font-weight: bold;
            text-decoration: underline;
            text-decoration-style: dotted;
            cursor: help;
        }
    </style>
</head>
<body>

<div class="activity-container">
    <div id="sentence-display">Loading sentences...</div>
    <button id="record-button" title="Click and Speak"><i class="fas fa-microphone"></i></button>
    <div class="feedback-area">
        <div id="user-transcription"></div>
        <div id="feedback-message"></div>
        <div class="navigation-buttons">
            <button id="retry-button" class="hide">Try Again</button>
            <button id="next-button" class="hide">Next</button>
        </div>
    </div>
</div>

<script>
    let sentences = [];
    let currentSentenceIndex = -1;
    let recognition;
    let resultFound = false;

    const sentenceDisplay = document.getElementById('sentence-display');
    const recordButton = document.getElementById('record-button');
    const userTranscription = document.getElementById('user-transcription');
    const feedbackMessage = document.getElementById('feedback-message');
    const retryButton = document.getElementById('retry-button');
    const nextButton = document.getElementById('next-button');

    document.addEventListener('DOMContentLoaded', () => {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const speechSynthesis = window.speechSynthesis;

        if (!SpeechRecognition || !speechSynthesis) {
            sentenceDisplay.textContent = "Sorry, your browser does not support the Web Speech API.";
            recordButton.disabled = true;
            return;
        }
        
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.lang = 'fr-FR';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => { recordButton.classList.add('listening'); recordButton.innerHTML = '<i class="fas fa-wave-square"></i>'; };

        recognition.onresult = (event) => {
            resultFound = true;
            const transcript = event.results[0][0].transcript;
            const confidence = event.results[0][0].confidence;
            checkAnswer(transcript, confidence);
        };

        recognition.onend = () => {
            recordButton.classList.remove('listening');
            recordButton.innerHTML = '<i class="fas fa-microphone"></i>';
            if (!resultFound) {
                feedbackMessage.textContent = 'Could not understand. Click the sentence to hear it, then try again.';
                feedbackMessage.className = 'incorrect';
                sentenceDisplay.classList.add('speakable');
                showNavigation('retry');
            }
        };

        recognition.onerror = (event) => {
            resultFound = true;
            let errorMessage = 'An error occurred. Please try again.';
            if (event.error === 'no-speech') {
                errorMessage = 'No speech was detected. Click the sentence to hear it, then try again.';
                sentenceDisplay.classList.add('speakable');
            } else if (event.error === 'not-allowed') {
                errorMessage = 'Microphone access was denied. Please allow access in your browser settings.';
            }
            feedbackMessage.textContent = errorMessage;
            feedbackMessage.className = 'incorrect';
            showNavigation('retry');
        };

        recordButton.addEventListener('click', () => { resultFound = false; resetFeedback(); recognition.start(); });
        retryButton.addEventListener('click', () => resetFeedback());
        nextButton.addEventListener('click', loadNextSentence);
        
        userTranscription.addEventListener('mouseover', (event) => {
            const target = event.target;
            if (target.classList.contains('incorrect') || target.classList.contains('suspicious')) {
                speakWord(target.dataset.speak);
            }
        });

        sentenceDisplay.addEventListener('click', () => {
            if (sentenceDisplay.classList.contains('speakable')) {
                speakWord(sentences[currentSentenceIndex]);
            }
        });

        fetchSentences();
    });

    function fetchSentences() {
        const params = new URLSearchParams(window.location.search);
        const sheetUrl = params.get('sheet');
        if (!sheetUrl) {
            sentenceDisplay.textContent = "⚠️ Please provide a Google Sheet URL in the '?sheet=' parameter.";
            recordButton.disabled = true;
            return;
        }
        Papa.parse(sheetUrl, {
            download: true,
            header: false,
            skipEmptyLines: true,
            complete: (results) => {
                const contentRows = results.data.slice(1);
                contentRows.forEach(row => {
                    if (row[5] && row[5].trim() !== '') {
                        sentences.push(row[5].trim());
                    }
                });
                if (sentences.length > 0) {
                    loadNextSentence();
                } else {
                    sentenceDisplay.textContent = "⚠️ No sentences found in Column F. Please check your sheet.";
                    recordButton.disabled = true;
                }
            },
            error: () => { sentenceDisplay.textContent = "⚠️ Failed to load spreadsheet. Check the URL and publish settings."; }
        });
    }

    function loadNextSentence() {
        if (sentences.length === 0) return;
        currentSentenceIndex = (currentSentenceIndex + 1) % sentences.length;
        sentenceDisplay.textContent = sentences[currentSentenceIndex];
        resetFeedback();
    }

    function normalizeText(text) {
        return text.toLowerCase().replace(/[.,\/#!?$%\^&\*;:{}=\-_`~()]/g, "").trim();
    }
    
    // Levenshtein distance function for "fuzzy" comparison
    const levenshtein = (s1, s2) => {
        let longer = s1;
        let shorter = s2;
        if (s1.length < s2.length) {
            longer = s2;
            shorter = s1;
        }
        let longerLength = longer.length;
        if (longerLength === 0) {
            return 1.0;
        }
        return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
    };

    const editDistance = (s1, s2) => {
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();
        const costs = [];
        for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
                if (i === 0) {
                    costs[j] = j;
                } else {
                    if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
            }
            if (i > 0) {
                costs[s2.length] = lastValue;
            }
        }
        return costs[s2.length];
    };


    function checkAnswer(transcript, confidence) {
        const FUZZY_THRESHOLD = 0.8; // How similar words must be to match (e.g., 0.8 = 80% similar)
        const CONFIDENCE_THRESHOLD = 0.85; 

        const correctSentence = sentences[currentSentenceIndex];
        const originalWords = correctSentence.split(' ').filter(w => w);
        const correctWordsNorm = originalWords.map(normalizeText);
        const userWordsNorm = normalizeText(transcript).split(' ').filter(w => w);
        
        let tempUserWords = [...userWordsNorm];
        let correctCount = 0;
        let feedbackHtml = '';

        const wordResults = correctWordsNorm.map(correctWord => {
            // Find the best fuzzy match for the current correct word in the user's transcript
            let bestMatchIndex = -1;
            let highestSimilarity = 0;

            tempUserWords.forEach((userWord, index) => {
                const similarity = levenshtein(correctWord, userWord);
                if (similarity > highestSimilarity) {
                    highestSimilarity = similarity;
                    bestMatchIndex = index;
                }
            });

            if (highestSimilarity >= FUZZY_THRESHOLD) {
                correctCount++;
                // Remove the matched word so it can't be matched again
                tempUserWords.splice(bestMatchIndex, 1);
                return { status: 'correct' };
            } else {
                return { status: 'incorrect' };
            }
        });
        
        originalWords.forEach((originalWord, index) => {
             if (wordResults[index] && wordResults[index].status === 'correct') {
                feedbackHtml += `<span class="word-feedback correct">${originalWord}</span> `;
             } else {
                feedbackHtml += `<span class="word-feedback incorrect" data-speak="${originalWord}">${originalWord}</span> `;
             }
        });
        
        userTranscription.innerHTML = feedbackHtml;
        const accuracy = Math.round((correctCount / correctWordsNorm.length) * 100);

        if (accuracy === 100) {
            if (confidence >= CONFIDENCE_THRESHOLD) {
                feedbackMessage.textContent = 'Correct!';
                feedbackMessage.className = 'correct';
            } else {
                userTranscription.innerHTML = originalWords.map(word => `<span class="word-feedback suspicious" data-speak="${word}">${word}</span>`).join(' ');
                feedbackMessage.innerHTML = `Text is correct, but pronunciation was unclear. <small>Confidence: ${Math.round(confidence * 100)}%</small>`;
                feedbackMessage.className = 'suspicious';
            }
            showNavigation('next');
        } else {
            feedbackMessage.innerHTML = `Not quite. &nbsp; <small>Accuracy: ${accuracy}%</small>`;
            feedbackMessage.className = 'incorrect';
            showNavigation('retry');
        }
    }

    function speakWord(word) {
        if (!word) return;
        speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = recognition.lang;
        speechSynthesis.speak(utterance);
    }

    function showNavigation(type) {
        recordButton.disabled = true;
        retryButton.classList.toggle('hide', type !== 'retry');
        nextButton.classList.toggle('hide', type !== 'next');
    }

    function resetFeedback() {
        recordButton.disabled = false;
        userTranscription.textContent = '';
        feedbackMessage.textContent = '';
        sentenceDisplay.classList.remove('speakable');
        retryButton.classList.add('hide');
        nextButton.classList.add('hide');
    }
</script>

</body>
</html>
