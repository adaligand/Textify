<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6196157933137237"
      crossorigin="anonymous"></script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tic Tac Toe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f9;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
    }
    
    .game-wrapper {
        background-color: white;
        padding: 20px 40px;
        border-radius: 15px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        text-align: center;
        width: 100%;
        max-width: 800px;
    }

    /* ADDED: New header to hold title and turn indicator */
    #game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
    }

    #game-header h1 {
        margin: 0;
    }

    #container { 
        display: flex; 
        justify-content: center; 
        align-items: flex-start; 
        gap: 20px; 
    }
    #grid { 
        display: grid; 
        gap: 10px; 
    }
    .cell { 
        position: relative; 
        width: 150px; 
        height: 150px; 
        border: 1px solid #999; 
        border-radius: 10px; 
        cursor: pointer; 
        background-color: #fafafa;
    }
    
    .cell-text {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 18px;
        font-weight: bold;
        padding: 5px;
        box-sizing: border-box;
        color: #333;
        pointer-events: none;
    }
    .overlay { 
        position: absolute; 
        top:0; left:0; 
        width:100%; height:100%; 
        background-color: rgba(255,0,0,0.4); 
        opacity:0; 
        border-radius:10px; 
        transition: opacity 0.3s; 
        pointer-events: none; 
    }
    .mark {
        position:absolute;
        top:0; left:0;
        width:100%; height:100%;
        display:flex;
        justify-content:center;
        align-items:center;
        font-size:120px;
        font-weight:bold;
        color:rgba(249, 249, 8, 0.871); 
        pointer-events:none;
        user-select:none;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    #words { display:flex; flex-direction: column; gap:10px; }

    .word { 
        padding: 10px; 
        border:1px solid #ccc; 
        border-radius:5px; 
        cursor: grab; 
        background-color:#f0f0f0; 
        user-select:none; 
        width: 180px;
        font-size: 16px;
        text-align: center;
        box-sizing: border-box;
        touch-action: none;
    }
    .word.dragging {
        opacity: 0.5;
    }

    .word-clone {
        position: fixed;
        pointer-events: none;
        z-index: 1000;
        opacity: 0.8;
        transform: rotate(5deg);
    }
    
    .player-score { 
        padding: 10px 15px; 
        border-radius:15px; 
        background-color:#f0f0f0; 
        font-size:18px; 
        width: 180px;
        text-align:center; 
        transition:all 0.3s ease; 
        box-sizing: border-box;
    }
    .player-score.active { 
        font-size:22px; 
        font-weight:bold; 
        background-color:#ffeaa7; 
    }

    #restart {
        margin-top: 20px;
    }

    /* --- ADDED MENU STYLES --- */
    #main-menu { text-align: center; margin-top: 50px; }
    .menu-button {
        display: block;
        width: 300px;
        padding: 15px 25px;
        margin: 15px auto;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        border-radius: 10px;
        background-color: #e0e0e0;
        border: 2px solid #ccc;
        color: #333;
        transition: all 0.2s ease-in-out;
    }
    .menu-button:hover { 
        background-color: #d0d0d0;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .hide { display: none !important; }
    /* --- END ADDED MENU STYLES --- */
</style>
</head>
<body>

<div class="game-wrapper">
    <div id="main-menu">
        <h1>Tic Tac Toe</h1>
        <p style="font-size: 18px; margin: 30px 0;">Select your game mode:</p>
        <button class="menu-button" id="pvc-button">PLAY VS COMPUTER</button>
        <button class="menu-button" id="pvp-button">2 PLAYERS</button>
    </div>
    <div id="game-area" class="hide">
        <div id="game-header">
            <h1>Tic Tac Toe</h1>
            <div id="turnIndicatorPanel" class="player-score active"></div>
        </div>
        <div id="container">
            <div id="grid"></div>
            <div id="words"></div>
        </div>
        <button id="restart">Restart Game</button>
    </div>
</div>

<script>
let allItemPairs = [];
let turn = 'X';
let gameOver = false;
let gameMode = ''; // 'pvp' or 'pvc'

let draggedItem = null;
let draggedItemClone = null;
let offsetX = 0;
let offsetY = 0;

const grid = document.getElementById('grid');
const wordsDiv = document.getElementById('words');
const restartBtn = document.getElementById('restart');
const turnIndicatorPanel = document.getElementById('turnIndicatorPanel'); 
const mainMenu = document.getElementById('main-menu');
const gameArea = document.getElementById('game-area');
const pvcBtn = document.getElementById('pvc-button');
const pvpBtn = document.getElementById('pvp-button');

const params = new URLSearchParams(window.location.search);
const sheetUrl = params.get('sheet');

// --- GAME MODE SELECTION ---
pvcBtn.addEventListener('click', () => startGame('pvc'));
pvpBtn.addEventListener('click', () => startGame('pvp'));
restartBtn.addEventListener('click', () => generateGame(gameMode));

function showMenu() {
    mainMenu.classList.remove('hide');
    gameArea.classList.add('hide');
    // Also reset the indicator just in case
    turnIndicatorPanel.textContent = ''; 
    restartBtn.style.display = 'none';
}

function startGame(mode) {
    gameMode = mode;
    mainMenu.classList.add('hide');
    gameArea.classList.remove('hide');
    
    // Check if data is loaded, otherwise just show loading error
    if (!sheetUrl) {
        document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è No sheet URL provided.</h1>";
    } else if (allItemPairs.length === 0) {
         // This assumes the Papa.parse call is in progress or failed. 
         // A more robust app would handle this, but for now, we'll wait 
         // for the data load or show the loading message.
         document.querySelector('.game-wrapper').innerHTML = "<h1>Loading data...</h1>";
    } else {
        generateGame(gameMode);
    }
}
// --- END GAME MODE SELECTION ---


// --- DATA LOADING ---
if (!sheetUrl) {
    document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è No sheet URL provided.</h1>";
} else {
    Papa.parse(sheetUrl, {
        download: true,
        header: false,
        skipEmptyLines: true,
        complete: function(results) {
            results.data.forEach((row, index) => {
                if (index === 0) return;
                if (row[1] && row[2]) {
                    allItemPairs.push({ 
                        term: row[1].trim(),
                        translation: row[2].trim()
                    });
                }
            });
            if (allItemPairs.length < 9) {
                document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è Not enough data. Requires 9+ rows.</h1>";
                return;
            }
            showMenu(); // Show menu after successful load
        },
        error: (err) => {
            console.error(err);
            document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è Error loading CSV file.</h1>";
        }
    });
}
// --- END DATA LOADING ---

function shuffle(array){
    for(let i=array.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [array[i],array[j]]=[array[j],array[i]];
    }
    return array;
}

function checkWinner(){
    const cells = [...document.querySelectorAll('#grid .mark')].map(m=>m.textContent);
    const winPatterns = [
        [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]
    ];
    for(const pattern of winPatterns){
        const [a,b,c] = pattern;
        if(cells[a] && cells[a]===cells[b] && cells[a]===cells[c]){
            const winnerText = cells[a] === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O');
            turnIndicatorPanel.textContent = `${winnerText} wins! üéâ`;
            gameOver = true;
            restartBtn.textContent = 'Play Again';
            restartBtn.style.display = "inline-block";
            return true;
        }
    }
    if(cells.every(c=>c)){
        turnIndicatorPanel.textContent = "It's a draw! ü§ù";
        gameOver = true;
        restartBtn.textContent = 'Play Again';
        restartBtn.style.display = "inline-block";
    }
    return false;
}

function switchTurn() {
    if (gameOver) return;
    turn = turn === 'X' ? 'O' : 'X';
    turnIndicatorPanel.textContent = `Turn: ${turn === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O')}`;

    if (gameMode === 'pvc' && turn === 'O') {
        setTimeout(computerMove, 1000); // Delay for computer's move
    }
}

/**
 * Handles the logic after a word is dropped/tapped on a cell.
 * @param {HTMLElement} cell - The cell element where the word was dropped.
 * @param {string} word - The term (word) being dropped.
 */
function handleDropLogic(cell, word) {
    if (gameOver) return;
    const mark = cell.querySelector('.mark');
    const overlay = cell.querySelector('.overlay');
    const wordEl = document.querySelector(`.word[data-word="${word}"]`);
    
    // Check if the cell is already marked
    if (mark.textContent) return; 

    // Check if the current player is 'O' (Computer) and it's a human drop in PVC mode
    if (gameMode === 'pvc' && turn === 'O' && !cell.classList.contains('cpu-move')) {
        // Human cannot move when it's the computer's turn
        return;
    }
    
    let isCorrect = (word === cell.dataset.correctTerm);

    if (isCorrect) {
        mark.textContent = turn;
        mark.style.color = turn === 'X' ? 'rgba(255,100,100,0.8)' : 'rgba(100,100,255,0.8)';
        
        // Remove the word from the list
        if (wordEl) wordEl.remove();
        
        // Remove the temporary class if it was a CPU move
        cell.classList.remove('cpu-move');

        if (!checkWinner()) {
            switchTurn();
        }
    } else {
        // Wrong answer: flash red and switch turn
        overlay.style.opacity = '0.7';
        setTimeout(() => overlay.style.opacity = '0', 500);

        // Remove the temporary class if it was a CPU move
        cell.classList.remove('cpu-move');
        
        switchTurn();
    }
}


function generateGame(mode){
    grid.innerHTML = '';
    wordsDiv.innerHTML = '';
    turn = 'X';
    gameOver = false;
    restartBtn.style.display = "none";
    turnIndicatorPanel.textContent = `Turn: Player X`;
    gameMode = mode; // Ensure gameMode is set

    let selected = shuffle([...allItemPairs]).slice(0,9);
    grid.style.gridTemplateColumns = `repeat(3, 150px)`;

    // Create Cells
    selected.forEach((pair, index)=>{
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.correctTerm = pair.term;
        cell.dataset.index = index; // Add index for computer logic
        cell.innerHTML = `
            <div class="cell-text">${pair.translation}</div>
            <div class="overlay"></div>
            <div class="mark"></div>
        `;
        // Setup Drag/Drop listeners for human player
        cell.addEventListener('dragover', e => e.preventDefault());
        cell.addEventListener('drop', e => {
            e.preventDefault();
            const draggedWord = e.dataTransfer.getData('text');
            handleDropLogic(cell, draggedWord);
        });
        grid.appendChild(cell);
    });

    // Create Word elements
    shuffle(selected).forEach(pair=>{
        const wordEl = document.createElement('div');
        wordEl.className = 'word';
        wordEl.textContent = pair.term;
        wordEl.setAttribute('draggable','true');
        wordEl.dataset.word = pair.term;
        
        // Drag events (for mouse)
        wordEl.addEventListener('dragstart', e => {
            if (gameOver || (gameMode === 'pvc' && turn === 'O')) {
                e.preventDefault();
                return;
            }
            e.dataTransfer.setData('text', pair.term);
            setTimeout(() => e.target.classList.add('dragging'), 0);
        });
        wordEl.addEventListener('dragend', e => e.target.classList.remove('dragging'));

        // Touch events (for mobile)
        wordEl.addEventListener('touchstart', e => {
            if (gameOver || (gameMode === 'pvc' && turn === 'O')) return;
            e.preventDefault();
            
            draggedItem = e.target;
            const rect = draggedItem.getBoundingClientRect();
            const touch = e.touches[0];

            offsetX = touch.clientX - rect.left;
            offsetY = touch.clientY - rect.top;

            draggedItemClone = draggedItem.cloneNode(true);
            draggedItemClone.classList.add('word-clone');
            
            draggedItemClone.style.width = `${rect.width}px`;
            draggedItemClone.style.height = `${rect.height}px`;
            draggedItemClone.style.left = `${touch.clientX - offsetX}px`;
            draggedItemClone.style.top = `${touch.clientY - offsetY}px`;

            document.body.appendChild(draggedItemClone);
            draggedItem.style.visibility = 'hidden';
        }, { passive: false });
        
        wordsDiv.appendChild(wordEl);
    });
    
    // Start the computer's turn if game mode is PVC and it's 'O'
    if (gameMode === 'pvc' && turn === 'O') {
        setTimeout(computerMove, 500);
    }
}

// --- COMPUTER LOGIC ---
function computerMove() {
    if (gameOver || turn !== 'O' || gameMode !== 'pvc') return;

    const availableCells = Array.from(document.querySelectorAll('#grid .cell')).filter(cell => !cell.querySelector('.mark').textContent);
    const remainingWords = Array.from(document.querySelectorAll('#words .word'));

    if (availableCells.length === 0 || remainingWords.length === 0) {
        // Should only happen on a draw, but just in case
        checkWinner();
        return;
    }

    // 1. Check for immediate win
    let winningMove = findWinningOrBlockingMove(availableCells, remainingWords, 'O');
    if (winningMove) {
        makeComputerMove(winningMove.cell, winningMove.word);
        return;
    }

    // 2. Block player 'X'
    let blockingMove = findWinningOrBlockingMove(availableCells, remainingWords, 'X');
    if (blockingMove) {
        makeComputerMove(blockingMove.cell, blockingMove.word);
        return;
    }

    // 3. Take the center (index 4) if available and a correct word exists for it
    const centerCell = document.querySelector('.cell[data-index="4"]');
    if (centerCell && !centerCell.querySelector('.mark').textContent) {
        const correctWord = remainingWords.find(wordEl => wordEl.dataset.word === centerCell.dataset.correctTerm);
        if (correctWord) {
            makeComputerMove(centerCell, correctWord.dataset.word);
            return;
        }
    }

    // 4. Take a random available corner (0, 2, 6, 8) if a correct word exists
    const corners = [0, 2, 6, 8];
    const availableCorners = availableCells.filter(cell => corners.includes(parseInt(cell.dataset.index)) && remainingWords.some(wordEl => wordEl.dataset.word === cell.dataset.correctTerm));
    if (availableCorners.length > 0) {
        const cell = availableCorners[Math.floor(Math.random() * availableCorners.length)];
        const word = remainingWords.find(wordEl => wordEl.dataset.word === cell.dataset.correctTerm).dataset.word;
        makeComputerMove(cell, word);
        return;
    }

    // 5. Pick a random available cell with a correct word
    const possibleMoves = availableCells.filter(cell => remainingWords.some(wordEl => wordEl.dataset.word === cell.dataset.correctTerm));
    if (possibleMoves.length > 0) {
        const cell = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        const word = remainingWords.find(wordEl => wordEl.dataset.word === cell.dataset.correctTerm).dataset.word;
        makeComputerMove(cell, word);
        return;
    }
    
    // Fallback: This should ideally not happen if all logic is right, but forces a turn switch/draw
    switchTurn(); 
}

function findWinningOrBlockingMove(availableCells, remainingWords, playerMark) {
    const cells = Array.from(document.querySelectorAll('#grid .mark'));
    const winPatterns = [
        [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]
    ];

    for (const pattern of winPatterns) {
        const [a, b, c] = pattern;
        const marks = [cells[a].textContent, cells[b].textContent, cells[c].textContent];

        // Check for two of playerMark and one empty cell
        if (marks.filter(m => m === playerMark).length === 2 && marks.filter(m => m === '').length === 1) {
            const emptyIndex = pattern[marks.findIndex(m => m === '')];
            const targetCell = availableCells.find(cell => parseInt(cell.dataset.index) === emptyIndex);
            
            if (targetCell) {
                const correctWord = remainingWords.find(wordEl => wordEl.dataset.word === targetCell.dataset.correctTerm);
                if (correctWord) {
                    return { cell: targetCell, word: correctWord.dataset.word };
                }
            }
        }
    }
    return null;
}

function makeComputerMove(cell, word) {
    // Add a temporary class to allow the computer's move to be processed by handleDropLogic
    cell.classList.add('cpu-move'); 
    
    // Visually simulate the "drop" by removing the word immediately before calling drop logic
    const wordEl = document.querySelector(`.word[data-word="${word}"]`);
    if (wordEl) {
        // Optional: you could add a subtle animation for the word disappearing here
        wordEl.remove();
    }
    
    // Execute the core logic
    handleDropLogic(cell, word);
}
// --- END COMPUTER LOGIC ---


// --- TOUCH/DRAG HANDLERS (Unchanged from original code) ---
document.addEventListener('touchmove', e => {
    if (!draggedItem || !draggedItemClone) return;
    e.preventDefault();

    const touch = e.touches[0];
    const newX = touch.clientX - offsetX;
    const newY = touch.clientY - offsetY;

    draggedItemClone.style.left = `${newX}px`;
    draggedItemClone.style.top = `${newY}px`;
}, { passive: false });

document.addEventListener('touchend', e => {
    if (!draggedItem) return;

    if (draggedItemClone) {
        document.body.removeChild(draggedItemClone);
    }
    draggedItemClone = null;

    const touch = e.changedTouches[0];
    const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
    const dropTarget = elementOver ? elementOver.closest('.cell') : null;

    if (dropTarget) {
        handleDropLogic(dropTarget, draggedItem.dataset.word);
    }
    
    if (draggedItem) {
        draggedItem.style.visibility = 'visible';
    }
    
    draggedItem = null;
});

// --- END TOUCH/DRAG HANDLERS ---
</script>
</body>
</html>
