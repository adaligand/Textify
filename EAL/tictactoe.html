<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tic Tac Toe ‚Äî Images + Words (PvP / PvC)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
  /* Page layout */
  body{
    font-family: Arial, sans-serif;
    background-color:#f4f4f9;
    display:flex;
    justify-content:center;
    align-items:center;
    min-height:100vh;
    margin:0;
    padding:20px;
    box-sizing:border-box;
  }
  .game-wrapper{
    background:#fff;
    padding:20px 30px;
    border-radius:15px;
    box-shadow:0 4px 12px rgba(0,0,0,.08);
    text-align:center;
    width:100%;
    max-width:900px;
  }

  /* Menu */
  #main-menu{ text-align:center; margin:30px 0 10px; }
  .menu-button{
    display:block; width:320px; margin:14px auto; padding:14px 20px; font-size:18px;
    font-weight:700; border-radius:10px; background:#e6e6e6; border:2px solid #ccc; cursor:pointer;
    transition:all .12s ease;
  }
  .menu-button:hover{ transform:translateY(-3px); box-shadow:0 6px 10px rgba(0,0,0,.06); }

  /* Header / turn indicator */
  #game-area { display:none; margin-top:10px; }
  #game-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; }
  #game-header h1{ margin:0; font-size:24px; }
  .player-score{ padding:10px 14px; border-radius:14px; background:#f0f0f0; font-weight:700; width:220px; text-align:center; }
  .player-score.active{ background:#ffeaa7; font-size:18px; }

  /* Layout */
  #container{ display:flex; justify-content:center; align-items:flex-start; gap:18px; }
  #grid{ display:grid; gap:10px; }
  .cell{ position:relative; width:150px; height:150px; border:1px solid #999; border-radius:10px; cursor:pointer; background:#fafafa; overflow:hidden; }
  .cell img{ width:100%; height:100%; object-fit:contain; border-radius:10px; display:block; }
  .overlay{ position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(255,0,0,.42); opacity:0; border-radius:10px; transition:opacity .28s; pointer-events:none; }
  .mark{ position:absolute; top:0; left:0; width:100%; height:100%; display:flex; justify-content:center; align-items:center; font-size:120px; font-weight:700; pointer-events:none; user-select:none; text-shadow:1px 1px 6px rgba(0,0,0,.2); }

  /* Word list */
  #words{ display:flex; flex-direction:column; gap:10px; width:200px; box-sizing:border-box; }
  .word{ padding:10px; border:1px solid #ccc; border-radius:6px; background:#f0f0f0; cursor:grab; user-select:none; text-align:center; font-weight:700; touch-action:none; }
  .word.dragging{ opacity:.5; }
  .word-clone{ position:fixed; pointer-events:none; z-index:1200; opacity:.95; transform-origin:center; border-radius:6px; box-shadow:0 8px 20px rgba(0,0,0,.12); }

  #restart{ margin-top:18px; padding:10px 16px; font-size:16px; border-radius:8px; background:#f0f0f0; border:1px solid #ccc; cursor:pointer; display:none; }

  .hide{ display:none !important; }
  .small-note{ font-size:13px; color:#666; margin-top:6px; }
</style>
</head>
<body>
<div class="game-wrapper">
  <div id="main-menu">
    <h1>Tic Tac Toe</h1>
    <p style="font-size:16px; margin:18px 0 8px;">Select your game mode:</p>
    <button class="menu-button" id="pvc-button">PLAY VS COMPUTER</button>
    <button class="menu-button" id="pvp-button">2 PLAYERS</button>
    <div class="small-note">(Provide CSV via `?sheet=CSV_URL`. CSV rows should be: anything, word, imageURL)</div>
  </div>

  <div id="game-area" class="hide">
    <div id="game-header">
      <h1>Tic Tac Toe</h1>
      <div id="turnIndicatorPanel" class="player-score active">Turn: Player X</div>
    </div>

    <div id="container">
      <div id="grid"></div>
      <div id="words"></div>
    </div>

    <button id="restart">Restart Game</button>
  </div>
</div>

<script>
/* ========= Data + State ========= */
let allItemPairs = [];        // { word, img }
let turn = 'X';
let gameOver = false;
let gameMode = '';           // 'pvp' or 'pvc'
let draggedItem = null;
let draggedItemClone = null;
let offsetX = 0, offsetY = 0;
let isAnimating = false;     // block human input while CPU animates

/* ========= DOM refs ========= */
const grid = document.getElementById('grid');
const wordsDiv = document.getElementById('words');
const restartBtn = document.getElementById('restart');
const turnIndicatorPanel = document.getElementById('turnIndicatorPanel');
const mainMenu = document.getElementById('main-menu');
const gameArea = document.getElementById('game-area');
const pvcBtn = document.getElementById('pvc-button');
const pvpBtn = document.getElementById('pvp-button');

/* ========= CSV loading ========= */
const params = new URLSearchParams(window.location.search);
const sheetUrl = params.get('sheet');

if (!sheetUrl) {
  document.querySelector('.game-wrapper').insertAdjacentHTML('beforeend', '<h3 style="color:#c44">‚ö†Ô∏è No sheet URL provided. Add ?sheet=CSV_URL</h3>');
} else {
  Papa.parse(sheetUrl, {
    download: true,
    header: false,
    skipEmptyLines: true,
    complete: function(results){
      results.data.forEach((row, index)=>{
        if(index === 0) return; // skip header if present
        if(row[1] && row[2]) {
          allItemPairs.push({ word: row[1].trim(), img: row[2].trim() });
        }
      });
      if(allItemPairs.length < 9){
        document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è Not enough data. Requires 9+ rows in CSV.</h1>";
        return;
      }
      // show menu now that data loaded
      mainMenu.classList.remove('hide');
    },
    error: function(err){
      console.error(err);
      document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è Error loading CSV file.</h1>";
    }
  });
}

/* ========= Menu handlers ========= */
pvcBtn.addEventListener('click', ()=> startGame('pvc'));
pvpBtn.addEventListener('click', ()=> startGame('pvp'));
restartBtn.addEventListener('click', ()=> generateGame(gameMode));

function showMenu(){
  mainMenu.classList.remove('hide');
  gameArea.classList.add('hide');
  restartBtn.style.display = 'none';
  turnIndicatorPanel.textContent = '';
}

function startGame(mode){
  gameMode = mode;
  mainMenu.classList.add('hide');
  gameArea.classList.remove('hide');
  if(!sheetUrl){ document.querySelector('.game-wrapper').innerHTML="<h1>‚ö†Ô∏è No sheet URL provided.</h1>"; return; }
  generateGame(gameMode);
}

/* ========= Utility ========= */
function shuffle(array){
  for(let i=array.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [array[i],array[j]]=[array[j],array[i]];
  }
  return array;
}

/* ========= Winner check ========= */
function checkWinner(){
  const marks = [...document.querySelectorAll('#grid .mark')].map(m=>m.textContent);
  const winPatterns = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for(const p of winPatterns){
    const [a,b,c] = p;
    if(marks[a] && marks[a] === marks[b] && marks[a] === marks[c]){
      const winnerText = marks[a] === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O');
      turnIndicatorPanel.textContent = `${winnerText} wins! üéâ`;
      gameOver = true;
      restartBtn.textContent = 'Play Again';
      restartBtn.style.display = 'inline-block';
      return true;
    }
  }
  if(marks.every(m=>m)){
    turnIndicatorPanel.textContent = "It's a draw! ü§ù";
    gameOver = true;
    restartBtn.textContent = 'Play Again';
    restartBtn.style.display = 'inline-block';
  }
  return false;
}

/* ========= Turn switching ========= */
function switchTurn(){
  if(gameOver) return;
  turn = turn === 'X' ? 'O' : 'X';
  turnIndicatorPanel.textContent = `Turn: ${turn === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O')}`;
  if(gameMode === 'pvc' && turn === 'O'){
    setTimeout(computerMove, 700);
  }
}

/* ========= Core drop logic ========= */
/* Handles both human drops and CPU final execution; checks animation flag etc. */
function handleDropLogic(cell, word){
  if(gameOver) return;
  if(isAnimating && !cell.classList.contains('cpu-move')) return; // prevent human interaction during CPU animation

  const mark = cell.querySelector('.mark');
  const overlay = cell.querySelector('.overlay');
  const wordEl = document.querySelector(`.word[data-word="${word}"]`);

  if(mark.textContent) return; // already filled

  // If pvc and it's O's turn but this is a human drop (cell not marked cpu-move) -> block
  if(gameMode === 'pvc' && turn === 'O' && !cell.classList.contains('cpu-move')) return;

  const isCorrect = (word === cell.dataset.correctTerm);

  if(isCorrect){
    mark.textContent = turn;
    mark.style.color = turn === 'X' ? 'rgba(255,100,100,0.9)' : 'rgba(100,100,255,0.9)';
    if(wordEl) wordEl.remove();
    cell.classList.remove('cpu-move');

    if(!checkWinner()){
      switchTurn();
    } else {
      // winner set; ensure isAnimating cleared
      isAnimating = false;
    }
  } else {
    overlay.style.opacity = '0.7';
    setTimeout(()=> overlay.style.opacity = '0', 500);
    cell.classList.remove('cpu-move');
    // if wrong and the word still exists, leave it (or append back)
    if(wordEl && !wordsDiv.contains(wordEl)) wordsDiv.appendChild(wordEl);
    switchTurn();
  }
}

/* ========= Game generation ========= */
function generateGame(mode){
  grid.innerHTML = '';
  wordsDiv.innerHTML = '';
  turn = 'X';
  gameOver = false;
  isAnimating = false;
  restartBtn.style.display = 'none';
  turnIndicatorPanel.textContent = `Turn: Player X`;
  gameMode = mode;

  let selected = shuffle([...allItemPairs]).slice(0,9);
  grid.style.gridTemplateColumns = `repeat(3, 150px)`;

  // Create cells
  selected.forEach((pair, index)=>{
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.correctTerm = pair.word;
    cell.dataset.index = index;
    cell.innerHTML = `
      <img src="${pair.img}" alt="" />
      <div class="overlay"></div>
      <div class="mark"></div>
    `;
    // Drag & drop listeners
    cell.addEventListener('dragover', e => e.preventDefault());
    cell.addEventListener('drop', e => {
      e.preventDefault();
      if(gameOver) return;
      const draggedWord = e.dataTransfer.getData('text');
      handleDropLogic(cell, draggedWord);
    });

    grid.appendChild(cell);
  });

  // Create word tiles (draggable / touch)
  shuffle(selected).forEach(pair=>{
    const wordEl = document.createElement('div');
    wordEl.className = 'word';
    wordEl.textContent = pair.word;
    wordEl.setAttribute('draggable','true');
    wordEl.dataset.word = pair.word;

    // Mouse drag
    wordEl.addEventListener('dragstart', e=>{
      if(gameOver || isAnimating || (gameMode === 'pvc' && turn === 'O')) { e.preventDefault(); return; }
      e.dataTransfer.setData('text', pair.word);
      setTimeout(()=> e.target.classList.add('dragging'), 0);
    });
    wordEl.addEventListener('dragend', e => e.target.classList.remove('dragging'));

    // Touch support -> create clone and follow touch
    wordEl.addEventListener('touchstart', e=>{
      if(gameOver || isAnimating || (gameMode === 'pvc' && turn === 'O')) return;
      e.preventDefault();
      draggedItem = e.target;
      const rect = draggedItem.getBoundingClientRect();
      const touch = e.touches[0];
      offsetX = touch.clientX - rect.left;
      offsetY = touch.clientY - rect.top;

      draggedItemClone = draggedItem.cloneNode(true);
      draggedItemClone.classList.add('word-clone');
      draggedItemClone.style.width = `${rect.width}px`;
      draggedItemClone.style.height = `${rect.height}px`;
      draggedItemClone.style.left = `${touch.clientX - offsetX}px`;
      draggedItemClone.style.top = `${touch.clientY - offsetY}px`;
      draggedItemClone.style.lineHeight = window.getComputedStyle(draggedItem).lineHeight;

      document.body.appendChild(draggedItemClone);
      draggedItem.style.visibility = 'hidden';
    }, { passive:false });

    wordsDiv.appendChild(wordEl);
  });

  // If PVC and CPU starts as O, schedule CPU move
  if(gameMode === 'pvc' && turn === 'O'){
    setTimeout(computerMove, 500);
  }
}

/* ========= Computer logic ========= */
function computerMove(){
  if(gameOver || turn !== 'O' || gameMode !== 'pvc') return;

  const availableCells = Array.from(document.querySelectorAll('#grid .cell')).filter(c => !c.querySelector('.mark').textContent);
  const remainingWords = Array.from(document.querySelectorAll('#words .word'));

  if(availableCells.length === 0 || remainingWords.length === 0){
    checkWinner();
    return;
  }

  // 1) Immediate win for O
  let winningMove = findWinningOrBlockingMove(availableCells, remainingWords, 'O');
  if(winningMove){ animateAndExecuteMove(winningMove.cell, winningMove.word); return; }

  // 2) Block X
  let blockingMove = findWinningOrBlockingMove(availableCells, remainingWords, 'X');
  if(blockingMove){ animateAndExecuteMove(blockingMove.cell, blockingMove.word); return; }

  // 3) Center
  const centerCell = document.querySelector('.cell[data-index="4"]');
  if(centerCell && !centerCell.querySelector('.mark').textContent){
    const cw = remainingWords.find(w => w.dataset.word === centerCell.dataset.correctTerm);
    if(cw){ animateAndExecuteMove(centerCell, cw.dataset.word); return; }
  }

  // 4) Corner (0,2,6,8)
  const corners = [0,2,6,8];
  const availableCorners = availableCells.filter(c => corners.includes(parseInt(c.dataset.index)) && remainingWords.some(w=>w.dataset.word === c.dataset.correctTerm));
  if(availableCorners.length > 0){
    const c = availableCorners[Math.floor(Math.random()*availableCorners.length)];
    const w = remainingWords.find(wEl => wEl.dataset.word === c.dataset.correctTerm).dataset.word;
    animateAndExecuteMove(c, w); return;
  }

  // 5) Any available correct cell
  const possible = availableCells.filter(c => remainingWords.some(w=>w.dataset.word === c.dataset.correctTerm));
  if(possible.length > 0){
    const c = possible[Math.floor(Math.random()*possible.length)];
    const w = remainingWords.find(wEl => wEl.dataset.word === c.dataset.correctTerm).dataset.word;
    animateAndExecuteMove(c, w); return;
  }

  // Fallback: wrong move to just switch turn
  switchTurn();
}

function findWinningOrBlockingMove(availableCells, remainingWords, playerMark){
  const marks = Array.from(document.querySelectorAll('#grid .mark'));
  const winPatterns = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

  for(const p of winPatterns){
    const [a,b,c] = p;
    const arr = [marks[a].textContent, marks[b].textContent, marks[c].textContent];
    if(arr.filter(x => x===playerMark).length === 2 && arr.filter(x => x==='').length === 1){
      const emptyIndex = p[arr.findIndex(x => x==='')];
      const targetCell = availableCells.find(cell => parseInt(cell.dataset.index) === emptyIndex);
      if(targetCell){
        const correctWord = remainingWords.find(w => w.dataset.word === targetCell.dataset.correctTerm);
        if(correctWord) return { cell: targetCell, word: correctWord.dataset.word };
      }
    }
  }
  return null;
}

/* ========= CPU animation & execution ========= */
function animateAndExecuteMove(cell, word){
  const wordEl = document.querySelector(`.word[data-word="${word}"]`);
  if(!wordEl){
    // If not found, execute directly but mark as cpu move so handleDropLogic won't be blocked by isAnimating
    cell.classList.add('cpu-move');
    handleDropLogic(cell, word);
    return;
  }

  const ANIM_MS = 900; // animation time
  const POST_DELAY = 40;

  isAnimating = true;
  const startRect = wordEl.getBoundingClientRect();
  const endRect = cell.getBoundingClientRect();

  const clone = wordEl.cloneNode(true);
  clone.classList.add('word-clone');
  clone.style.width = `${startRect.width}px`;
  clone.style.height = `${startRect.height}px`;
  clone.style.left = `${startRect.left}px`;
  clone.style.top = `${startRect.top}px`;
  clone.style.transition = `all ${ANIM_MS/1000}s ease-in-out`;
  document.body.appendChild(clone);
  wordEl.style.opacity = '0.25';

  setTimeout(()=>{
    clone.style.left = `${endRect.left + (endRect.width/2) - (startRect.width/2)}px`;
    clone.style.top = `${endRect.top + (endRect.height/2) - (startRect.height/2)}px`;
    clone.style.transform = 'scale(0.85)';
    clone.style.opacity = '0.95';
  }, 20);

  setTimeout(()=>{
    // cleanup clone, remove wordEl, execute move logic
    if(clone.parentNode) clone.parentNode.removeChild(clone);
    if(wordEl.parentNode) wordEl.parentNode.removeChild(wordEl);
    wordEl.style.opacity = '1';
    // mark cell as cpu move so handleDropLogic will accept it while isAnimating used
    cell.classList.add('cpu-move');
    handleDropLogic(cell, word);
    isAnimating = false;
  }, ANIM_MS + POST_DELAY);
}

/* ========= Touch global handlers for dragging clones ========= */
document.addEventListener('touchmove', e=>{
  if(!draggedItem || !draggedItemClone || isAnimating) return;
  e.preventDefault();
  const touch = e.touches[0];
  const newX = touch.clientX - offsetX;
  const newY = touch.clientY - offsetY;
  draggedItemClone.style.left = `${newX}px`;
  draggedItemClone.style.top = `${newY}px`;
}, { passive:false });

document.addEventListener('touchend', e=>{
  if(!draggedItem || isAnimating) return;
  if(draggedItemClone && draggedItemClone.parentNode) draggedItemClone.parentNode.removeChild(draggedItemClone);
  draggedItemClone = null;

  const touch = e.changedTouches[0];
  const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
  const dropTarget = elementOver ? elementOver.closest('.cell') : null;

  if(dropTarget){
    handleDropLogic(dropTarget, draggedItem.dataset.word);
  }
  if(draggedItem) draggedItem.style.visibility = 'visible';
  draggedItem = null;
});

/* ========= Prevent accidental interactions during animation / CPU turn ========= */
document.addEventListener('click', (e)=>{
  // If CPU animating, prevent clicks on word tiles (user would still see cursor but nothing happens)
  if(isAnimating) e.stopImmediatePropagation();
}, true);

/* ========= END ========= */
</script>
</body>
</html>
