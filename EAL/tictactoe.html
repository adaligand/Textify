<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tic Tac Toe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
  body{font-family:Arial, Helvetica, sans-serif;background:#f4f4f9;min-height:100vh;display:flex;align-items:center;justify-content:center;margin:0;padding:20px;box-sizing:border-box}
  .game-wrapper{background:#fff;padding:20px 40px;border-radius:15px;box-shadow:0 4px 12px rgba(0,0,0,0.1);text-align:center;width:100%;max-width:800px}
  #game-header{display:flex;justify-content:space-between;align-items:center;width:100%;margin-bottom:20px}
  #container{display:flex;justify-content:center;align-items:flex-start;gap:20px}
  #grid{display:grid;gap:10px}
  .cell{position:relative;width:150px;height:150px;border:1px solid #999;border-radius:10px;background:#fafafa;overflow:hidden;cursor:pointer}
  .tile-image{width:100%;height:100%;object-fit:contain;display:block;border-radius:10px;background:#fff}
  .overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.4);opacity:0;border-radius:10px;transition:opacity .3s;pointer-events:none}
  .mark{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:120px;font-weight:bold;color:rgba(100,100,255,0.8);pointer-events:none;user-select:none;text-shadow:2px 2px 4px rgba(0,0,0,0.5)}
  #words{display:flex;flex-direction:column;gap:10px;max-height:520px;overflow:auto}
  .word{padding:10px;border:1px solid #ccc;border-radius:5px;background:#f0f0f0;cursor:grab;user-select:none;width:180px;font-size:16px;text-align:center;box-sizing:border-box;touch-action:none}
  .word.dragging{opacity:.5}
  .word-clone{position:fixed;pointer-events:none;z-index:1000;opacity:.9;transform:rotate(0deg)}
  .player-score{padding:10px 15px;border-radius:15px;background:#f0f0f0;font-size:18px;width:180px;text-align:center;transition:all .3s;box-sizing:border-box}
  .player-score.active{font-size:22px;font-weight:bold;background:#ffeaa7}
  #restart{margin-top:20px;display:none}
  #main-menu{text-align:center;margin-top:50px}
  .menu-button{display:block;width:300px;padding:15px 25px;margin:15px auto;font-size:18px;font-weight:bold;cursor:pointer;border-radius:10px;background:#e0e0e0;border:2px solid #ccc;color:#333;transition:all .2s}
  .menu-button:hover{background:#d0d0d0;transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,0.1)}
  .menu-button[disabled]{opacity:.6;cursor:not-allowed;transform:none}
  .hide{display:none !important}
  @media(max-width:820px){#container{flex-direction:column;align-items:center}}
</style>
</head>
<body>
  <div class="game-wrapper" id="gameWrapper">
    <div id="main-menu">
      <h1>Tic Tac Toe</h1>
      <p style="font-size:18px;margin:30px 0">Select your game mode:</p>
      <button class="menu-button" id="pvc-button" disabled>Loading...</button>
      <button class="menu-button" id="pvp-button" disabled>Loading...</button>
    </div>

    <div id="game-area" class="hide">
      <div id="game-header">
        <h1>Tic Tac Toe</h1>
        <div id="turnIndicatorPanel" class="player-score active"></div>
      </div>
      <div id="container">
        <div id="grid"></div>
        <div id="words"></div>
      </div>
      <button id="restart">Restart Game</button>
    </div>
  </div>

<script>
/* Minimal explanations only where helpful. Implementation mirrors your second file but with robust loading handling. */
let allItemPairs = []; // { term, img }
let turn = 'X';
let gameOver = false;
let gameMode = ''; // 'pvp' or 'pvc'
let draggedItem = null, draggedItemClone = null, offsetX = 0, offsetY = 0;
let isAnimating = false;

const grid = document.getElementById('grid');
const wordsDiv = document.getElementById('words');
const restartBtn = document.getElementById('restart');
const turnIndicatorPanel = document.getElementById('turnIndicatorPanel');
const mainMenu = document.getElementById('main-menu');
const gameArea = document.getElementById('game-area');
const pvcBtn = document.getElementById('pvc-button');
const pvpBtn = document.getElementById('pvp-button');
const gameWrapper = document.getElementById('gameWrapper');

const params = new URLSearchParams(window.location.search);
const sheetUrl = params.get('sheet');

pvcBtn.addEventListener('click', () => startGame('pvc'));
pvpBtn.addEventListener('click', () => startGame('pvp'));
restartBtn.addEventListener('click', () => generateGame(gameMode));

function enableModeButtons() {
  pvcBtn.disabled = false;
  pvpBtn.disabled = false;
  pvcBtn.textContent = 'PLAY VS COMPUTER';
  pvpBtn.textContent = '2 PLAYERS';
}

function showMenu() {
  mainMenu.classList.remove('hide');
  gameArea.classList.add('hide');
  turnIndicatorPanel.textContent = '';
  restartBtn.style.display = 'none';
}

function startGame(mode) {
  // If data isn't ready, keep buttons visible and show a small notice.
  if (!sheetUrl) {
    gameWrapper.innerHTML = "<h1>‚ö†Ô∏è No sheet URL provided.</h1>";
    return;
  }
  if (allItemPairs.length === 0) {
    // data still loading ‚Äî do not replace DOM; instead briefly flash text on buttons (they will be disabled)
    pvcBtn.textContent = 'Loading...';
    pvpBtn.textContent = 'Loading...';
    return;
  }
  gameMode = mode;
  mainMenu.classList.add('hide');
  gameArea.classList.remove('hide');
  generateGame(gameMode);
}

/* CSV load ‚Äî keep UI intact while parsing */
if (!sheetUrl) {
  gameWrapper.innerHTML = "<h1>‚ö†Ô∏è No sheet URL provided.</h1>";
} else {
  // keep buttons disabled until parse finishes
  Papa.parse(sheetUrl, {
    download: true,
    header: false,
    skipEmptyLines: true,
    complete: function(results) {
      results.data.forEach((row, index) => {
        if (index === 0) return;
        if (row[1] && row[2]) {
          allItemPairs.push({ term: row[1].trim(), img: row[2].trim() });
        }
      });
      if (allItemPairs.length < 9) {
        gameWrapper.innerHTML = "<h1>‚ö†Ô∏è Not enough data. Requires 9+ rows.</h1>";
        return;
      }
      enableModeButtons(); // enable mode selection
      showMenu();
    },
    error: function(err) {
      console.error(err);
      gameWrapper.innerHTML = "<h1>‚ö†Ô∏è Error loading CSV file.</h1>";
    }
  });
}

/* utilities */
function shuffle(array){ for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]];} return array; }

function checkWinner(){
  const cells = [...document.querySelectorAll('#grid .mark')].map(m=>m.textContent);
  const winPatterns = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for(const pattern of winPatterns){
    const [a,b,c] = pattern;
    if(cells[a] && cells[a]===cells[b] && cells[a]===cells[c]){
      const winnerText = cells[a] === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O');
      turnIndicatorPanel.textContent = `${winnerText} wins! üéâ`;
      gameOver = true;
      restartBtn.textContent = 'Play Again';
      restartBtn.style.display = "inline-block";
      return true;
    }
  }
  if(cells.every(c=>c)){
    turnIndicatorPanel.textContent = "It's a draw! ü§ù";
    gameOver = true;
    restartBtn.textContent = 'Play Again';
    restartBtn.style.display = "inline-block";
  }
  return false;
}

function switchTurn(){
  if (gameOver) return;
  turn = turn === 'X' ? 'O' : 'X';
  turnIndicatorPanel.textContent = `Turn: ${turn === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O')}`;
  if (gameMode === 'pvc' && turn === 'O') setTimeout(computerMove, 1000);
}

/* main drop logic */
function handleDropLogic(cell, word){
  if (gameOver) return;
  if (isAnimating && !cell.classList.contains('cpu-move')) return;

  const mark = cell.querySelector('.mark');
  const overlay = cell.querySelector('.overlay');
  const wordEl = document.querySelector(`.word[data-word="${CSS && CSS.escape ? CSS.escape(word) : word}"]`);

  if (mark.textContent) return;
  if (gameMode === 'pvc' && turn === 'O' && !cell.classList.contains('cpu-move')) return;

  const isCorrect = (word === cell.dataset.correctTerm);
  if (isCorrect){
    mark.textContent = turn;
    mark.style.color = turn === 'X' ? 'rgba(255,100,100,0.8)' : 'rgba(100,100,255,0.8)';
    if (wordEl) wordEl.remove();
    cell.classList.remove('cpu-move');
    if (!checkWinner()) switchTurn();
  } else {
    overlay.style.opacity = '0.7';
    setTimeout(()=>overlay.style.opacity='0',500);
    cell.classList.remove('cpu-move');
    switchTurn();
  }
}

/* generate game: tiles show images from CSV column C */
function generateGame(mode){
  grid.innerHTML = '';
  wordsDiv.innerHTML = '';
  turn = 'X';
  gameOver = false;
  isAnimating = false;
  restartBtn.style.display = "none";
  turnIndicatorPanel.textContent = `Turn: Player X`;
  gameMode = mode;

  const selected = shuffle([...allItemPairs]).slice(0,9);
  grid.style.gridTemplateColumns = `repeat(3,150px)`;

  selected.forEach((pair, index) => {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.correctTerm = pair.term;
    cell.dataset.index = index;

    const img = document.createElement('img');
    img.className = 'tile-image';
    img.src = pair.img;
    img.alt = pair.term;

    const overlay = document.createElement('div'); overlay.className = 'overlay';
    const mark = document.createElement('div'); mark.className = 'mark';

    cell.appendChild(img); cell.appendChild(overlay); cell.appendChild(mark);

    cell.addEventListener('dragover', e => e.preventDefault());
    cell.addEventListener('drop', e => {
      e.preventDefault();
      const draggedWord = e.dataTransfer.getData('text');
      handleDropLogic(cell, draggedWord);
    });

    grid.appendChild(cell);
  });

  shuffle(selected).forEach(pair=>{
    const wordEl = document.createElement('div');
    wordEl.className = 'word';
    wordEl.textContent = pair.term;
    wordEl.setAttribute('draggable','true');
    wordEl.dataset.word = pair.term;

    wordEl.addEventListener('dragstart', e => {
      if (gameOver || isAnimating || (gameMode === 'pvc' && turn === 'O')) { e.preventDefault(); return; }
      e.dataTransfer.setData('text', pair.term);
      setTimeout(()=>e.target.classList.add('dragging'),0);
    });
    wordEl.addEventListener('dragend', e => e.target.classList.remove('dragging'));

    wordEl.addEventListener('touchstart', e => {
      if (gameOver || isAnimating || (gameMode === 'pvc' && turn === 'O')) return;
      e.preventDefault();
      draggedItem = e.target;
      const rect = draggedItem.getBoundingClientRect();
      const touch = e.touches[0];
      offsetX = touch.clientX - rect.left;
      offsetY = touch.clientY - rect.top;
      draggedItemClone = draggedItem.cloneNode(true);
      draggedItemClone.classList.add('word-clone');
      draggedItemClone.style.width = `${rect.width}px`;
      draggedItemClone.style.height = `${rect.height}px`;
      draggedItemClone.style.left = `${touch.clientX - offsetX}px`;
      draggedItemClone.style.top = `${touch.clientY - offsetY}px`;
      draggedItem.style.visibility = 'hidden';
      document.body.appendChild(draggedItemClone);
    }, { passive: false });

    wordsDiv.appendChild(wordEl);
  });

  if (gameMode === 'pvc' && turn === 'O') setTimeout(computerMove, 500);
}

/* CPU logic same heuristics */
function computerMove(){
  if (gameOver || turn !== 'O' || gameMode !== 'pvc') return;
  const availableCells = Array.from(document.querySelectorAll('#grid .cell')).filter(c => !c.querySelector('.mark').textContent);
  const remainingWords = Array.from(document.querySelectorAll('#words .word'));
  if (availableCells.length === 0 || remainingWords.length === 0) { checkWinner(); return; }

  let winningMove = findWinningOrBlockingMove(availableCells, remainingWords, 'O');
  if (winningMove) { animateAndExecuteMove(winningMove.cell, winningMove.word); return; }
  let blockingMove = findWinningOrBlockingMove(availableCells, remainingWords, 'X');
  if (blockingMove) { animateAndExecuteMove(blockingMove.cell, blockingMove.word); return; }

  const centerCell = document.querySelector('.cell[data-index="4"]');
  if (centerCell && !centerCell.querySelector('.mark').textContent){
    const correctWord = remainingWords.find(w => w.dataset.word === centerCell.dataset.correctTerm);
    if (correctWord) { animateAndExecuteMove(centerCell, correctWord.dataset.word); return; }
  }

  const corners = [0,2,6,8];
  const availableCorners = availableCells.filter(cell => corners.includes(parseInt(cell.dataset.index)) && remainingWords.some(w => w.dataset.word === cell.dataset.correctTerm));
  if (availableCorners.length > 0){
    const cell = availableCorners[Math.floor(Math.random()*availableCorners.length)];
    const word = remainingWords.find(w => w.dataset.word === cell.dataset.correctTerm).dataset.word;
    animateAndExecuteMove(cell, word); return;
  }

  const possibleMoves = availableCells.filter(cell => remainingWords.some(w => w.dataset.word === cell.dataset.correctTerm));
  if (possibleMoves.length > 0){
    const cell = possibleMoves[Math.floor(Math.random()*possibleMoves.length)];
    const word = remainingWords.find(w => w.dataset.word === cell.dataset.correctTerm).dataset.word;
    animateAndExecuteMove(cell, word); return;
  }

  switchTurn();
}

function findWinningOrBlockingMove(availableCells, remainingWords, playerMark){
  const cells = Array.from(document.querySelectorAll('#grid .mark'));
  const winPatterns = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for (const pattern of winPatterns){
    const [a,b,c] = pattern;
    const marks = [cells[a].textContent, cells[b].textContent, cells[c].textContent];
    if (marks.filter(m=>m===playerMark).length === 2 && marks.filter(m=>m==='').length === 1){
      const emptyIndex = pattern[marks.findIndex(m=>m==='')];
      const targetCell = availableCells.find(cell => parseInt(cell.dataset.index) === emptyIndex);
      if (targetCell){
        const correctWord = remainingWords.find(w => w.dataset.word === targetCell.dataset.correctTerm);
        if (correctWord) return { cell: targetCell, word: correctWord.dataset.word };
      }
    }
  }
  return null;
}

/* animate CPU: clone word -> move to cell -> apply logic */
function animateAndExecuteMove(cell, word){
  const wordEl = document.querySelector(`.word[data-word="${CSS && CSS.escape ? CSS.escape(word) : word}"]`);
  if (!wordEl){ cell.classList.add('cpu-move'); handleDropLogic(cell, word); return; }
  const ANIMATION_DURATION_MS = 1500, POST_ANIMATION_DELAY_MS = 50;
  isAnimating = true;
  const startRect = wordEl.getBoundingClientRect();
  const endRect = cell.getBoundingClientRect();
  const clone = wordEl.cloneNode(true);
  clone.classList.add('word-clone');
  clone.style.width = `${startRect.width}px`;
  clone.style.height = `${startRect.height}px`;
  clone.style.left = `${startRect.left}px`;
  clone.style.top = `${startRect.top}px`;
  clone.style.transition = `all ${ANIMATION_DURATION_MS/1000}s ease-in-out`;
  document.body.appendChild(clone);
  wordEl.style.opacity = '0.3';
  setTimeout(()=> {
    clone.style.left = `${endRect.left + (endRect.width/2) - (startRect.width/2)}px`;
    clone.style.top = `${endRect.top + (endRect.height/2) - (startRect.height/2)}px`;
    clone.style.transform = 'scale(0.8)';
  }, POST_ANIMATION_DELAY_MS);
  setTimeout(()=> {
    wordEl.remove();
    if (document.body.contains(clone)) document.body.removeChild(clone);
    wordEl.style.opacity = '1';
    cell.classList.add('cpu-move');
    handleDropLogic(cell, word);
    isAnimating = false;
  }, ANIMATION_DURATION_MS + POST_ANIMATION_DELAY_MS);
}

/* mobile touch drag */
document.addEventListener('touchmove', e => {
  if (!draggedItem || !draggedItemClone || isAnimating) return;
  e.preventDefault();
  const touch = e.touches[0];
  const newX = touch.clientX - offsetX, newY = touch.clientY - offsetY;
  draggedItemClone.style.left = `${newX}px`; draggedItemClone.style.top = `${newY}px`;
}, { passive: false });

document.addEventListener('touchend', e => {
  if (!draggedItem || isAnimating) return;
  if (draggedItemClone) document.body.removeChild(draggedItemClone);
  draggedItemClone = null;
  const touch = e.changedTouches[0];
  const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
  const dropTarget = elementOver ? elementOver.closest('.cell') : null;
  if (dropTarget) handleDropLogic(dropTarget, draggedItem.dataset.word);
  if (draggedItem) draggedItem.style.visibility = 'visible';
  draggedItem = null;
});
</script>
</body>
</html>
