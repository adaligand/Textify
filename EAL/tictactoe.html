<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tic Tac Toe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f9;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
    }
    .game-wrapper {
        background-color: white;
        padding: 20px 40px;
        border-radius: 15px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        text-align: center;
        width: 100%;
        max-width: 800px;
    }
    /* header */
    #game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
    }
    #game-header h1 { margin: 0; }
    #container { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }
    #grid { display: grid; gap: 10px; }
    .cell { 
        position: relative; 
        width: 150px; 
        height: 150px; 
        border: 1px solid #999; 
        border-radius: 10px; 
        cursor: pointer; 
        background-color: #fafafa;
        overflow: hidden;
    }
    /* image inside tile */
    .cell img.tile-image {
        width: 100%;
        height: 100%;
        object-fit: contain; /* show image properly */
        display: block;
        border-radius: 10px;
        background: #fff;
    }
    .overlay { 
        position: absolute; 
        top:0; left:0; 
        width:100%; height:100%; 
        background-color: rgba(255,0,0,0.4); 
        opacity:0; 
        border-radius:10px; 
        transition: opacity 0.3s; 
        pointer-events: none; 
    }
    .mark {
        position:absolute;
        top:0; left:0;
        width:100%; height:100%;
        display:flex;
        justify-content:center;
        align-items:center;
        font-size:120px;
        font-weight:bold;
        color:rgba(100,100,255,0.8);
        pointer-events:none;
        user-select:none;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    #words { display:flex; flex-direction: column; gap:10px; max-height:520px; overflow:auto; }
    .word { 
        padding: 10px; 
        border:1px solid #ccc; 
        border-radius:5px; 
        cursor: grab; 
        background-color:#f0f0f0; 
        user-select:none; 
        width: 180px;
        font-size: 16px;
        text-align: center;
        box-sizing: border-box;
        touch-action: none;
    }
    .word.dragging { opacity: 0.5; }
    .word-clone {
        position: fixed;
        pointer-events: none;
        z-index: 1000;
        opacity: 0.9;
        transform: rotate(0deg);
    }
    .player-score { 
        padding: 10px 15px; 
        border-radius:15px; 
        background-color:#f0f0f0; 
        font-size:18px; 
        width: 180px;
        text-align:center; 
        transition:all 0.3s ease; 
        box-sizing: border-box;
    }
    .player-score.active { 
        font-size:22px; 
        font-weight:bold; 
        background-color:#ffeaa7; 
    }
    #restart { margin-top: 20px; display:none; }
    /* menu */
    #main-menu { text-align: center; margin-top: 50px; }
    .menu-button {
        display: block;
        width: 300px;
        padding: 15px 25px;
        margin: 15px auto;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        border-radius: 10px;
        background-color: #e0e0e0;
        border: 2px solid #ccc;
        color: #333;
        transition: all 0.2s ease-in-out;
    }
    .menu-button:hover { 
        background-color: #d0d0d0;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .hide { display: none !important; }
    @media(max-width:820px){ #container { flex-direction:column; align-items:center; } }
</style>
</head>
<body>

<div class="game-wrapper">
    <div id="main-menu">
        <h1>Tic Tac Toe</h1>
        <p style="font-size: 18px; margin: 30px 0;">Select your game mode:</p>
        <button class="menu-button" id="pvc-button">PLAY VS COMPUTER</button>
        <button class="menu-button" id="pvp-button">2 PLAYERS</button>
    </div>
    <div id="game-area" class="hide">
        <div id="game-header">
            <h1>Tic Tac Toe</h1>
            <div id="turnIndicatorPanel" class="player-score active"></div>
        </div>
        <div id="container">
            <div id="grid"></div>
            <div id="words"></div>
        </div>
        <button id="restart">Restart Game</button>
    </div>
</div>

<script>
/* Minimal inline comments: only on why. Implementation follows your second file exactly except tiles show images. */
let allItemPairs = [];      // each: { term, img }
let turn = 'X';
let gameOver = false;
let gameMode = ''; // 'pvp' or 'pvc'
let draggedItem = null;
let draggedItemClone = null;
let offsetX = 0;
let offsetY = 0;
let isAnimating = false;

const grid = document.getElementById('grid');
const wordsDiv = document.getElementById('words');
const restartBtn = document.getElementById('restart');
const turnIndicatorPanel = document.getElementById('turnIndicatorPanel'); 
const mainMenu = document.getElementById('main-menu');
const gameArea = document.getElementById('game-area');
const pvcBtn = document.getElementById('pvc-button');
const pvpBtn = document.getElementById('pvp-button');

const params = new URLSearchParams(window.location.search);
const sheetUrl = params.get('sheet');

pvcBtn.addEventListener('click', () => startGame('pvc'));
pvpBtn.addEventListener('click', () => startGame('pvp'));
restartBtn.addEventListener('click', () => generateGame(gameMode));

function showMenu() {
    mainMenu.classList.remove('hide');
    gameArea.classList.add('hide');
    turnIndicatorPanel.textContent = ''; 
    restartBtn.style.display = 'none';
}

function startGame(mode) {
    gameMode = mode;
    mainMenu.classList.add('hide');
    gameArea.classList.remove('hide');
    if (!sheetUrl) {
        document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è No sheet URL provided.</h1>";
    } else if (allItemPairs.length === 0) {
         document.querySelector('.game-wrapper').innerHTML = "<h1>Loading data...</h1>";
    } else {
        generateGame(gameMode);
    }
}

/* CSV: expect column B (index 1) = term, column C (index 2) = image URL */
if (!sheetUrl) {
    document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è No sheet URL provided.</h1>";
} else {
    Papa.parse(sheetUrl, {
        download: true,
        header: false,
        skipEmptyLines: true,
        complete: function(results) {
            results.data.forEach((row, index) => {
                if (index === 0) return;
                if (row[1] && row[2]) {
                    allItemPairs.push({ term: row[1].trim(), img: row[2].trim() });
                }
            });
            if (allItemPairs.length < 9) {
                document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è Not enough data. Requires 9+ rows.</h1>";
                return;
            }
            showMenu();
        },
        error: (err) => {
            console.error(err);
            document.querySelector('.game-wrapper').innerHTML = "<h1>‚ö†Ô∏è Error loading CSV file.</h1>";
        }
    });
}

function shuffle(array){
    for(let i=array.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [array[i],array[j]]=[array[j],array[i]];
    }
    return array;
}

function checkWinner(){
    const cells = [...document.querySelectorAll('#grid .mark')].map(m=>m.textContent);
    const winPatterns = [
        [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]
    ];
    for(const pattern of winPatterns){
        const [a,b,c] = pattern;
        if(cells[a] && cells[a]===cells[b] && cells[a]===cells[c]){
            const winnerText = cells[a] === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O');
            turnIndicatorPanel.textContent = `${winnerText} wins! üéâ`;
            gameOver = true;
            restartBtn.textContent = 'Play Again';
            restartBtn.style.display = "inline-block";
            return true;
        }
    }
    if(cells.every(c=>c)){
        turnIndicatorPanel.textContent = "It's a draw! ü§ù";
        gameOver = true;
        restartBtn.textContent = 'Play Again';
        restartBtn.style.display = "inline-block";
    }
    return false;
}

function switchTurn() {
    if (gameOver) return;
    turn = turn === 'X' ? 'O' : 'X';
    turnIndicatorPanel.textContent = `Turn: ${turn === 'X' ? 'Player X' : (gameMode === 'pvc' ? 'Computer (O)' : 'Player O')}`;
    if (gameMode === 'pvc' && turn === 'O') {
        setTimeout(computerMove, 1000);
    }
}

/* Only block human interaction while CPU animation runs. */
function handleDropLogic(cell, word) {
    if (gameOver) return; 
    if (isAnimating && !cell.classList.contains('cpu-move')) return; 

    const mark = cell.querySelector('.mark');
    const overlay = cell.querySelector('.overlay');
    const safeWord = word;
    const wordEl = document.querySelector(`.word[data-word="${safeWord}"]`); // term strings are simple

    if (mark.textContent) return; 
    if (gameMode === 'pvc' && turn === 'O' && !cell.classList.contains('cpu-move')) return;

    let isCorrect = (word === cell.dataset.correctTerm);

    if (isCorrect) {
        mark.textContent = turn;
        mark.style.color = turn === 'X' ? 'rgba(255,100,100,0.8)' : 'rgba(100,100,255,0.8)';
        if (wordEl) wordEl.remove();
        cell.classList.remove('cpu-move');
        if (!checkWinner()) switchTurn();
    } else {
        overlay.style.opacity = '0.7';
        setTimeout(() => overlay.style.opacity = '0', 500);
        cell.classList.remove('cpu-move');
        switchTurn();
    }
}

/* Generate grid where tiles show images (from CSV column C). */
function generateGame(mode){
    grid.innerHTML = '';
    wordsDiv.innerHTML = '';
    turn = 'X';
    gameOver = false;
    isAnimating = false;
    restartBtn.style.display = "none";
    turnIndicatorPanel.textContent = `Turn: Player X`;
    gameMode = mode;

    let selected = shuffle([...allItemPairs]).slice(0,9);
    grid.style.gridTemplateColumns = `repeat(3, 150px)`;

    selected.forEach((pair, index)=>{
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.correctTerm = pair.term;
        cell.dataset.index = index;

        const img = document.createElement('img');
        img.className = 'tile-image';
        img.src = pair.img;
        img.alt = pair.term;

        const overlay = document.createElement('div'); overlay.className = 'overlay';
        const mark = document.createElement('div'); mark.className = 'mark';

        cell.appendChild(img);
        cell.appendChild(overlay);
        cell.appendChild(mark);

        cell.addEventListener('dragover', e => e.preventDefault());
        cell.addEventListener('drop', e => {
            e.preventDefault();
            const draggedWord = e.dataTransfer.getData('text');
            handleDropLogic(cell, draggedWord);
        });

        grid.appendChild(cell);
    });

    shuffle(selected).forEach(pair=>{
        const wordEl = document.createElement('div');
        wordEl.className = 'word';
        wordEl.textContent = pair.term;
        wordEl.setAttribute('draggable','true');
        wordEl.dataset.word = pair.term;

        wordEl.addEventListener('dragstart', e => {
            if (gameOver || isAnimating || (gameMode === 'pvc' && turn === 'O')) { e.preventDefault(); return; }
            e.dataTransfer.setData('text', pair.term);
            setTimeout(() => e.target.classList.add('dragging'), 0);
        });
        wordEl.addEventListener('dragend', e => e.target.classList.remove('dragging'));

        wordEl.addEventListener('touchstart', e => {
            if (gameOver || isAnimating || (gameMode === 'pvc' && turn === 'O')) return;
            e.preventDefault();
            draggedItem = e.target;
            const rect = draggedItem.getBoundingClientRect();
            const touch = e.touches[0];
            offsetX = touch.clientX - rect.left;
            offsetY = touch.clientY - rect.top;
            draggedItemClone = draggedItem.cloneNode(true);
            draggedItemClone.classList.add('word-clone');
            draggedItemClone.style.width = `${rect.width}px`;
            draggedItemClone.style.height = `${rect.height}px`;
            draggedItemClone.style.left = `${touch.clientX - offsetX}px`;
            draggedItemClone.style.top = `${touch.clientY - offsetY}px`;
            draggedItem.style.visibility = 'hidden';
            document.body.appendChild(draggedItemClone);
        }, { passive: false });

        wordsDiv.appendChild(wordEl);
    });

    if (gameMode === 'pvc' && turn === 'O') setTimeout(computerMove, 500);
}

/* CPU logic: same heuristics as your second file. */
function computerMove() {
    if (gameOver || turn !== 'O' || gameMode !== 'pvc') return;

    const availableCells = Array.from(document.querySelectorAll('#grid .cell')).filter(cell => !cell.querySelector('.mark').textContent);
    const remainingWords = Array.from(document.querySelectorAll('#words .word'));

    if (availableCells.length === 0 || remainingWords.length === 0) { checkWinner(); return; }

    let winningMove = findWinningOrBlockingMove(availableCells, remainingWords, 'O');
    if (winningMove) { animateAndExecuteMove(winningMove.cell, winningMove.word); return; }

    let blockingMove = findWinningOrBlockingMove(availableCells, remainingWords, 'X');
    if (blockingMove) { animateAndExecuteMove(blockingMove.cell, blockingMove.word); return; }

    const centerCell = document.querySelector('.cell[data-index="4"]');
    if (centerCell && !centerCell.querySelector('.mark').textContent) {
        const correctWord = remainingWords.find(wordEl => wordEl.dataset.word === centerCell.dataset.correctTerm);
        if (correctWord) { animateAndExecuteMove(centerCell, correctWord.dataset.word); return; }
    }

    const corners = [0,2,6,8];
    const availableCorners = availableCells.filter(cell => corners.includes(parseInt(cell.dataset.index)) && remainingWords.some(wordEl => wordEl.dataset.word === cell.dataset.correctTerm));
    if (availableCorners.length > 0) {
        const cell = availableCorners[Math.floor(Math.random() * availableCorners.length)];
        const word = remainingWords.find(wordEl => wordEl.dataset.word === cell.dataset.correctTerm).dataset.word;
        animateAndExecuteMove(cell, word); return;
    }

    const possibleMoves = availableCells.filter(cell => remainingWords.some(wordEl => wordEl.dataset.word === cell.dataset.correctTerm));
    if (possibleMoves.length > 0) {
        const cell = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        const word = remainingWords.find(wordEl => wordEl.dataset.word === cell.dataset.correctTerm).dataset.word;
        animateAndExecuteMove(cell, word); return;
    }
    switchTurn();
}

function findWinningOrBlockingMove(availableCells, remainingWords, playerMark) {
    const cells = Array.from(document.querySelectorAll('#grid .mark'));
    const winPatterns = [
        [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]
    ];
    for (const pattern of winPatterns) {
        const [a, b, c] = pattern;
        const marks = [cells[a].textContent, cells[b].textContent, cells[c].textContent];
        if (marks.filter(m => m === playerMark).length === 2 && marks.filter(m => m === '').length === 1) {
            const emptyIndex = pattern[marks.findIndex(m => m === '')];
            const targetCell = availableCells.find(cell => parseInt(cell.dataset.index) === emptyIndex);
            if (targetCell) {
                const correctWord = remainingWords.find(wordEl => wordEl.dataset.word === targetCell.dataset.correctTerm);
                if (correctWord) return { cell: targetCell, word: correctWord.dataset.word };
            }
        }
    }
    return null;
}

/* CPU animation: clone word, move to target cell over 1.5s, then apply logic. */
function animateAndExecuteMove(cell, word) {
    const wordEl = document.querySelector(`.word[data-word="${word}"]`);
    if (!wordEl) { cell.classList.add('cpu-move'); handleDropLogic(cell, word); return; }

    const ANIMATION_DURATION_MS = 1500;
    const POST_ANIMATION_DELAY_MS = 50;
    isAnimating = true;

    const startRect = wordEl.getBoundingClientRect();
    const endRect = cell.getBoundingClientRect();

    const clone = wordEl.cloneNode(true);
    clone.classList.add('word-clone');
    clone.style.width = `${startRect.width}px`;
    clone.style.height = `${startRect.height}px`;
    clone.style.left = `${startRect.left}px`;
    clone.style.top = `${startRect.top}px`;
    clone.style.transition = `all ${ANIMATION_DURATION_MS / 1000}s ease-in-out`;
    document.body.appendChild(clone);
    wordEl.style.opacity = '0.3';

    setTimeout(() => {
        clone.style.left = `${endRect.left + (endRect.width / 2) - (startRect.width / 2)}px`;
        clone.style.top = `${endRect.top + (endRect.height / 2) - (startRect.height / 2)}px`;
        clone.style.transform = 'scale(0.8)';
    }, POST_ANIMATION_DELAY_MS);

    setTimeout(() => {
        wordEl.remove();
        if (document.body.contains(clone)) document.body.removeChild(clone);
        wordEl.style.opacity = '1';
        cell.classList.add('cpu-move');
        handleDropLogic(cell, word);
        isAnimating = false;
    }, ANIMATION_DURATION_MS + POST_ANIMATION_DELAY_MS);
}

/* Touch drag behavior for mobile. */
document.addEventListener('touchmove', e => {
    if (!draggedItem || !draggedItemClone || isAnimating) return;
    e.preventDefault();
    const touch = e.touches[0];
    const newX = touch.clientX - offsetX;
    const newY = touch.clientY - offsetY;
    draggedItemClone.style.left = `${newX}px`;
    draggedItemClone.style.top = `${newY}px`;
}, { passive: false });

document.addEventListener('touchend', e => {
    if (!draggedItem || isAnimating) return;
    if (draggedItemClone) { document.body.removeChild(draggedItemClone); }
    draggedItemClone = null;
    const touch = e.changedTouches[0];
    const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
    const dropTarget = elementOver ? elementOver.closest('.cell') : null;
    if (dropTarget) handleDropLogic(dropTarget, draggedItem.dataset.word);
    if (draggedItem) draggedItem.style.visibility = 'visible';
    draggedItem = null;
});
</script>
</body>
</html>
