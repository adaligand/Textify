<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Tic Tac Toe — Words & Images</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f9;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    padding: 20px;
    box-sizing: border-box;
  }
  .game-wrapper {
      background-color: white;
      padding: 20px 40px;
      border-radius: 15px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      text-align: center;
      width: 900px;
      max-width: calc(100% - 40px);
  }
  #controls { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; gap:12px; flex-wrap:wrap; }
  .modes { display:flex; gap:10px; align-items:center; }
  .mode-label { cursor:pointer; padding:6px 10px; border-radius:8px; border:1px solid #ddd; background:#fafafa; }
  #container { display: flex; justify-content: center; align-items: flex-start; gap: 20px; flex-wrap:wrap; }
  #grid { display: grid; gap: 10px; }
  .cell {
    position: relative;
    width: 150px;
    height: 150px;
    border: 1px solid #999;
    border-radius: 10px;
    cursor: pointer;
    overflow: hidden;
    background: #fff;
  }
 .cell img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  border-radius: 10px;
}
  .overlay {
    position: absolute;
    top:0; left:0;
    width:100%; height:100%;
    background-color: rgba(255,0,0,0.25);
    opacity:0;
    border-radius:10px;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  .mark {
    position:absolute;
    top:0; left:0;
    width:100%; height:100%;
    display:flex;
    justify-content:center;
    align-items:center;
    font-size:200px;
    font-weight:bold;
    color:rgba(249, 249, 8, 0.871);
    pointer-events:none;
    user-select:none;
  }
  #words { display:flex; flex-direction: column; gap:10px; min-width:180px; max-height:520px; overflow:auto; }
  .word {
    padding:5px 10px;
    border:1px solid #ccc;
    border-radius:5px;
    cursor: grab;
    background-color:#f0f0f0;
    user-select:none;
    width: 180px;
    text-align: center;
    box-sizing: border-box;
  }
  #turn { margin-top:20px; font-size:20px; font-weight:bold; }
  #restart {
    margin-top:15px;
    padding:8px 15px;
    font-size:16px;
    border:1px solid #ccc;
    border-radius:5px;
    background-color:#f0f0f0;
    cursor:pointer;
    display:none;
  }
  @media(max-width:820px){
    #container { flex-direction:column; align-items:center; }
  }
</style>
</head>
<body>
<div class="game-wrapper">
    <h1>Tic Tac Toe</h1>

    <div id="controls">
      <div class="modes">
        <label class="mode-label">
          <input type="radio" name="mode" value="pvp" checked /> Two Players
        </label>
        <label class="mode-label">
          <input type="radio" name="mode" value="cpu" /> Play vs Computer
        </label>
      </div>
      <div style="text-align:right">
        <small>Provide CSV sheet URL as `?sheet=...`</small>
      </div>
    </div>

    <div id="container">
      <div id="grid"></div>
      <div id="words"></div>
    </div>

    <div id="turn">Turn: X</div>
    <button id="restart">Restart Game</button>
</div>

<script>
/* ======= State ======= */
let allItemPairs = [];
let turn = 'X';
let gameOver = false;
const grid = document.getElementById('grid');
const wordsDiv = document.getElementById('words');
const turnDiv = document.getElementById('turn');
const restartBtn = document.getElementById('restart');
const modeInputs = document.querySelectorAll('input[name="mode"]');

let mode = 'pvp';       // 'pvp' or 'cpu'
const playerSymbol = 'X';
const cpuSymbol = 'O';
const cpuDelay = 700;   // ms delay before CPU moves

/* ======= CSV load ======= */
const params = new URLSearchParams(window.location.search);
const sheetUrl = params.get('sheet');

if (!sheetUrl) {
    document.querySelector('.game-wrapper').innerHTML = "<h1>⚠️ No sheet URL provided.</h1><p>Append ?sheet=CSV_URL to the page URL.</p>";
} else {
    Papa.parse(sheetUrl, {
        download: true,
        header: false,
        skipEmptyLines: true,
        complete: function(results) {
            results.data.forEach((row, index) => {
                if (index === 0) return;
                if (row[1] && row[2]) {
                    allItemPairs.push({ word: row[1].trim(), img: row[2].trim() });
                }
            });

            if (allItemPairs.length < 9) {
                document.querySelector('.game-wrapper').innerHTML = "<h1>⚠️ Not enough data. The game requires at least 9 rows in the spreadsheet.</h1>";
                return;
            }

            generateGame();
        },
        error: function(err) {
            console.error(err);
            document.querySelector('.game-wrapper').innerHTML = "<h1>⚠️ Error loading CSV file.</h1>";
        }
    });
}

/* ======= Utilities ======= */
function shuffle(array){
  for(let i=array.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [array[i],array[j]]=[array[j],array[i]];
  }
  return array;
}

/* Return the 9 .cell elements in order */
function getCells(){
  return Array.from(document.querySelectorAll('.cell'));
}

/* ======= Winner check ======= */
function checkWinner(){
  const cells = [...document.querySelectorAll('.cell .mark')].map(m=>m.textContent);
  const winPatterns = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];
  for(const pattern of winPatterns){
    const [a,b,c] = pattern;
    if(cells[a] && cells[a]===cells[b] && cells[a]===cells[c]){
      turnDiv.textContent = cells[a] + " wins!";
      gameOver = true;
      restartBtn.style.display = "inline-block";
      return true;
    }
  }
  if(cells.every(c=>c)){ // draw
    turnDiv.textContent = "It's a draw!";
    gameOver = true;
    restartBtn.style.display = "inline-block";
  }
  return false;
}

/* ======= CPU move (simple random correct placement) ======= */
function cpuMove(){
  if(gameOver) return;
  // gather word elements that are still available
  const availableWords = Array.from(wordsDiv.querySelectorAll('.word'));
  // candidate: word whose target cell currently has no mark
  const candidates = [];
  for(const w of availableWords){
    const targetCell = document.querySelector(`.cell[data-word="${CSS.escape(w.dataset.word)}"]`);
    if(targetCell){
      const mark = targetCell.querySelector('.mark');
      if(mark && !mark.textContent) candidates.push({ wordEl: w, targetCell });
    }
  }

  // pick candidate or fallback to any empty cell
  let chosen = null;
  if(candidates.length){
    chosen = candidates[Math.floor(Math.random()*candidates.length)];
  } else {
    // fallback: any empty cell
    const empties = getCells().filter(c=>!c.querySelector('.mark').textContent);
    if(empties.length){
      const cell = empties[Math.floor(Math.random()*empties.length)];
      // if there is a matching word element, remove it; otherwise just place mark
      const w = Array.from(availableWords).find(we => we.dataset.word === cell.dataset.word);
      chosen = { wordEl: w || null, targetCell: cell };
    }
  }

  if(!chosen) return;

  // perform placement
  const { wordEl, targetCell } = chosen;
  const mark = targetCell.querySelector('.mark');
  if(mark && !mark.textContent){
    mark.textContent = cpuSymbol;
    mark.style.color = cpuSymbol==='X' ? 'rgba(255,100,100,0.7)' : 'rgba(100,100,255,0.7)';
    if(wordEl) wordEl.remove();
    if(!checkWinner()){
      turn = playerSymbol;
      turnDiv.textContent = 'Turn: '+turn;
    }
  }
}

/* ======= Main generator ======= */
function generateGame(){
  grid.innerHTML = '';
  wordsDiv.innerHTML = '';
  turn = 'X';
  gameOver = false;
  restartBtn.style.display = "none";
  turnDiv.textContent = "Turn: X";

  let selected = shuffle([...allItemPairs]).slice(0,9);
  const columns = 3;
  grid.style.gridTemplateColumns = `repeat(${columns}, 150px)`;

  selected.forEach(pair=>{
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.word = pair.word;

    const img = document.createElement('img');
    img.src = pair.img;
    img.alt = pair.word;
    cell.appendChild(img);

    const overlay = document.createElement('div');
    overlay.className='overlay';
    cell.appendChild(overlay);

    const mark = document.createElement('div');
    mark.className='mark';
    cell.appendChild(mark);

    /* drag & drop handling for drops (human only) */
    cell.addEventListener('dragover', e => e.preventDefault());
    cell.addEventListener('drop', e=>{
      if(gameOver) return;
      // if mode is vs CPU and it's not human's turn, ignore drops
      if(mode === 'cpu' && turn !== playerSymbol) return;

      const dragged = e.dataTransfer.getData('text');
      const wordEl = document.querySelector(`.word[data-word='${CSS.escape(dragged)}']`);

      if(dragged===cell.dataset.word && !mark.textContent){
        mark.textContent = turn;
        mark.style.color = turn==='X'?'rgba(255,100,100,0.7)':'rgba(100,100,255,0.7)';
        if(wordEl) wordEl.remove();
        if(!checkWinner()){
          turn = turn==='X'?'O':'X';
          turnDiv.textContent = 'Turn: '+turn;
          // if CPU mode and now CPU's turn, schedule CPU move
          if(mode === 'cpu' && turn === cpuSymbol && !gameOver){
            setTimeout(cpuMove, cpuDelay);
          }
        }
      } else {
        overlay.style.opacity='0.7';
        setTimeout(()=>overlay.style.opacity='0',500);
        // return word element to list if it exists (keeps order simple)
        if(wordEl) wordsDiv.appendChild(wordEl);

        // toggle turn on miss
        turn = turn==='X'?'O':'X';
        turnDiv.textContent = 'Turn: '+turn;
        // If correctness caused CPU's turn, schedule CPU
        if(mode === 'cpu' && turn === cpuSymbol && !gameOver){
          setTimeout(cpuMove, cpuDelay);
        }
      }
    });

    grid.appendChild(cell);
  });

  // create shuffled word list - words correspond to selected pairs but shuffled
  shuffle(selected).forEach(pair=>{
    const wordEl = document.createElement('div');
    wordEl.className = 'word';
    wordEl.textContent = pair.word;
    wordEl.setAttribute('draggable','true');
    wordEl.dataset.word=pair.word;
    wordEl.addEventListener('dragstart', e=>{
      // block drag if game over or (vs CPU and not player's turn)
      if(gameOver) { e.preventDefault(); return; }
      if(mode === 'cpu' && turn !== playerSymbol){ e.preventDefault(); return; }
      e.dataTransfer.setData('text',pair.word);
    });
    wordsDiv.appendChild(wordEl);
  });

  // If CPU starts first (rare because we start with X), handle that case:
  if(mode === 'cpu' && turn === cpuSymbol && !gameOver){
    setTimeout(cpuMove, cpuDelay);
  }
}

/* ======= Event listeners ======= */
restartBtn.addEventListener('click', generateGame);

modeInputs.forEach(inp=>{
  inp.addEventListener('change', e=>{
    mode = e.target.value === 'cpu' ? 'cpu' : 'pvp';
    generateGame();
  });
});

/* ensure initial mode is read */
mode = document.querySelector('input[name="mode"]:checked').value === 'cpu' ? 'cpu' : 'pvp';
</script>
</body>
</html>
