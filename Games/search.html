<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search - Language Practice</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Nunito&display=swap" rel="stylesheet" />
    <style>
        /* --- General and Layout Styles --- */
        body {
            font-family: 'Nunito', Arial, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }
        h1 {
            width: 100%;
            text-align: center;
            color: #3498db; /* Primary header color */
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        /* --- Grid & Overlay Container --- */
        #grid-and-overlay-container {
            position: relative;
            flex: 1 1 600px; /* Make the grid container larger */
            max-width: 600px; /* Fixed max width for the grid area */
            margin: 0 auto;
            aspect-ratio: 1 / 1; /* Keep it square */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* --- Grid Letters --- */
        #wordSearchGrid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            z-index: 1; /* Letters below the drawing canvas */
        }
        .grid-cell {
            display: flex; /* Use flex to center content */
            justify-content: center;
            align-items: center;
            font-size: 1.6em; /* Bigger font for larger grid */
            font-weight: bold;
            color: #333;
            background-color: transparent; /* No background by default */
            border: none; /* No visible borders */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s;
        }
        .grid-cell:hover:not(.found-text) { /* Keep hover for cells not part of a found word */
            background-color: rgba(100, 100, 100, 0.1); /* Subtle hover */
        }
        /* Temporary selection highlight for individual cells */
        .grid-cell.selected-temp {
            background-color: rgba(255, 237, 153, 0.5); /* Semi-transparent selection */
        }
        /* New class for cells that are part of a found word */
        .grid-cell.found-text {
            color: white; /* Text color changes for found words */
        }

        /* --- Canvas Overlay for Drawing Lines --- */
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Drawing on top of letters */
            pointer-events: none; /* Allows mouse events to pass through to the grid cells below */
        }

        /* --- Word List Styles (Right side) --- */
        #wordList {
            flex: 1 1 300px; /* Reduced space for word list */
            padding: 10px 15px; /* Reduced padding */
            background-color: white; /* Match overall container background */
            border-radius: 10px;
        }
        /* No h2 for word list headline */
        .word-item-wrapper {
            margin-bottom: 8px; /* Space between word boxes */
        }
        .word-item {
            display: inline-block; /* Make it a box */
            padding: 8px 12px;
            font-size: 1.1em;
            color: #555;
            background-color: #ecf0f1; /* Light grey box */
            border-radius: 8px; /* Rounded corners */
            transition: all 0.3s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .word-item.found {
            text-decoration: none; /* No strikethrough for image-like style */
            color: white;
            background-color: #2ecc71; /* Green background for found */
            font-style: normal;
            opacity: 1;
            box-shadow: 0 2px 5px rgba(46, 204, 113, 0.3); /* Subtle green shadow */
        }

        /* --- Message Styles --- */
        #message {
            width: 100%;
            text-align: center;
            margin-top: 20px;
            font-size: 1.4em;
            font-weight: bold;
            color: #e74c3c;
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            #grid-and-overlay-container {
                order: 1;
                max-width: 90%; /* Allow grid to take more width on smaller screens */
            }
            #wordList {
                order: 2;
                width: 90%;
                margin-top: 20px;
                text-align: center; /* Center word boxes */
            }
            .word-item {
                 font-size: 1em; /* Smaller font for words on mobile */
                 padding: 6px 10px;
            }
            .grid-cell {
                font-size: 1.2em; /* Smaller font for grid letters on mobile */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Word Search</h1>
        <div id="grid-and-overlay-container">
            <div id="wordSearchGrid">Loading...</div>
            <canvas id="drawingCanvas"></canvas>
        </div>
        <div id="wordList">
            <div id="translationList">Awaiting data...</div>
        </div>
        <div id="message"></div>
    </div>

    <script>
        // --- Configuration ---
        const GRID_SIZE = 15; // 15x15 grid
        const MAX_WORDS = 10; // Max number of words to place from the spreadsheet
        const foreignColumn = 1; // Column B (index 1)
        const englishColumn = 2; // Column C (index 2)

        // --- Game State ---
        let wordPairs = []; // [{foreign: "Mots", english: "Words", found: false, startCell: null, endCell: null}]
        let grid = [];
        let selectedCells = []; // Stores actual cell DOM elements
        let isMouseDown = false;
        let foundCount = 0;

        // --- DOM Elements ---
        const gridAndOverlayContainer = document.getElementById('grid-and-overlay-container');
        const gridElement = document.getElementById('wordSearchGrid');
        const translationListElement = document.getElementById('translationList');
        const messageElement = document.getElementById('message');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const ctx = drawingCanvas.getContext('2d');

        const params = new URLSearchParams(window.location.search);
        const sheetUrl = params.get('sheet');

        let cellWidth = 0; // Will be calculated after grid is rendered
        let cellHeight = 0;

        // --- Data Loading and Initialization ---

        function loadWords() {
            if (!sheetUrl) {
                messageElement.textContent = "‚ö†Ô∏è Error: No CSV URL provided in the 'sheet' parameter.";
                return;
            }

            Papa.parse(sheetUrl, {
                download: true,
                header: false,
                skipEmptyLines: true,
                complete: function (results) {
                    const data = results.data.slice(1); // Skip header row
                    let availableWords = data
                        .map(row => ({
                            foreign: row[foreignColumn] ? row[foreignColumn].trim().toUpperCase().replace(/[^A-Z√Ä√Ç√Ñ√â√à√ä√ã√é√è√î√ñ√ô√õ√ú√á]/g, '') : '',
                            english: row[englishColumn] ? row[englishColumn].trim() : ''
                        }))
                        .filter(pair => pair.foreign.length >= 3 && pair.foreign.length <= GRID_SIZE);

                    // Select a maximum number of words, and add placeholder for start/end cells
                    wordPairs = availableWords.slice(0, MAX_WORDS).map(pair => ({
                        ...pair,
                        found: false,
                        startCell: null, // Store actual grid cells for drawing
                        endCell: null
                    }));

                    if (wordPairs.length === 0) {
                        messageElement.textContent = "‚ö†Ô∏è No suitable words found in the spreadsheet.";
                        return;
                    }

                    initializeGame();
                },
                error: function (err) {
                    messageElement.textContent = "‚ö†Ô∏è Error loading the CSV file: " + err.message;
                    console.error(err);
                }
            });
        }

        // --- Word Search Grid Logic ---

        const directions = [
            { row: 0, col: 1 },    // Horizontal (right)
            { row: 1, col: 0 },    // Vertical (down)
            { row: 1, col: 1 },    // Diagonal (down-right)
            { row: 1, col: -1 },   // Diagonal (down-left)
            { row: 0, col: -1 },   // Horizontal (left)
            { row: -1, col: 0 },   // Vertical (up)
            { row: -1, col: -1 },  // Diagonal (up-left)
            { row: -1, col: 1 },   // Diagonal (up-right)
        ];

        function initializeGrid() {
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
            
            gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            gridElement.innerHTML = '';
            
            let placedWordsDetails = []; // To store the actual placement info for validation

            // Shuffle wordPairs to randomize placement order for better distribution
            wordPairs.sort(() => Math.random() - 0.5);

            wordPairs.forEach(wordPair => {
                const word = wordPair.foreign;
                let success = false;
                
                // Try placement up to 200 times
                for (let attempt = 0; attempt < 200; attempt++) {
                    const startRow = Math.floor(Math.random() * GRID_SIZE);
                    const startCol = Math.floor(Math.random() * GRID_SIZE);
                    const dirIndex = Math.floor(Math.random() * directions.length);
                    const dir = directions[dirIndex];

                    if (canPlaceWord(word, startRow, startCol, dir)) {
                        placeWord(word, startRow, startCol, dir);
                        placedWordsDetails.push({
                            word: word,
                            start: { row: startRow, col: startCol },
                            end: { row: startRow + (word.length - 1) * dir.row, col: startCol + (word.length - 1) * dir.col }
                        });
                        success = true;
                        break;
                    }
                }
                if (!success) {
                    console.warn(`Could not place word: ${word}`);
                }
            });

            // Update wordPairs with their actual grid positions
            wordPairs = wordPairs.filter(pair => placedWordsDetails.some(pd => pd.word === pair.foreign));
            wordPairs.forEach(pair => {
                const details = placedWordsDetails.find(pd => pd.word === pair.foreign);
                if (details) {
                    pair.startCoords = details.start;
                    pair.endCoords = details.end;
                }
            });


            // Fill remaining empty cells with random letters
            const fillerLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Ç√Ñ√â√à√ä√ã√é√è√î√ñ√ô√õ√ú√á";
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === null) {
                        const randomLetter = fillerLetters[Math.floor(Math.random() * fillerLetters.length)];
                        grid[r][c] = randomLetter;
                    }
                }
            }

            // Render the grid
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.textContent = grid[r][c];
                    gridElement.appendChild(cell);
                }
            }
            
            // Adjust canvas size to match the grid's runtime size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const containerRect = gridAndOverlayContainer.getBoundingClientRect();
            drawingCanvas.width = containerRect.width;
            drawingCanvas.height = containerRect.height;
            
            // Recalculate cell dimensions
            cellWidth = containerRect.width / GRID_SIZE;
            cellHeight = containerRect.height / GRID_SIZE;

            // Redraw all found words if any exist
            if (foundCount > 0) {
                drawFoundWordsOnCanvas();
            }
        }

        function canPlaceWord(word, startRow, startCol, dir) {
            for (let i = 0; i < word.length; i++) {
                const r = startRow + i * dir.row;
                const c = startCol + i * dir.col;

                if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) {
                    return false; // Out of bounds
                }
                if (grid[r][c] !== null && grid[r][c] !== word[i]) {
                    return false; // Conflict with existing letter
                }
            }
            return true;
        }

        function placeWord(word, startRow, startCol, dir) {
            for (let i = 0; i < word.length; i++) {
                const r = startRow + i * dir.row;
                const c = startCol + i * dir.col;
                grid[r][c] = word[i];
            }
        }

        // --- Word List Rendering ---

        function renderWordList() {
            translationListElement.innerHTML = '';
            wordPairs.forEach((pair, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'word-item-wrapper';

                const item = document.createElement('span');
                item.className = `word-item ${pair.found ? 'found' : ''}`;
                item.id = `word-item-${index}`;
                item.textContent = pair.english; 
                wrapper.appendChild(item);
                translationListElement.appendChild(wrapper);
            });
        }

        // --- Selection and Validation Logic ---

        function initializeGame() {
            initializeGrid();
            renderWordList();
            setupSelectionListeners();
        }

        function setupSelectionListeners() {
            // Mouse events
            gridElement.addEventListener('mousedown', startSelection);
            gridElement.addEventListener('mouseup', endSelection);
            document.addEventListener('mouseup', endSelection); 
            gridElement.addEventListener('mouseover', moveSelection);

            // Touch events
            gridElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.classList.contains('grid-cell')) {
                    startSelection({ target: target });
                }
            }, { passive: false });
            gridElement.addEventListener('touchend', endSelection);
            gridElement.addEventListener('touchcancel', endSelection); // Important for touches
            gridElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.classList.contains('grid-cell')) {
                    moveSelection({ target: target });
                }
            }, { passive: false });
        }

        function getCellFromEventTarget(target) {
            return target.closest('.grid-cell');
        }

        function startSelection(e) {
            const cell = getCellFromEventTarget(e.target);
            if (!cell || cell.classList.contains('found-text')) return;

            isMouseDown = true;
            clearSelection();
            messageElement.textContent = ""; // Clear previous message
            selectCell(cell);
        }

        function moveSelection(e) {
            if (!isMouseDown) return;

            const newCell = getCellFromEventTarget(e.target);
            if (!newCell || selectedCells.includes(newCell)) return; // Don't re-select same cell

            if (selectedCells.length === 0) {
                selectCell(newCell);
                return;
            }

            const firstCell = selectedCells[0];
            const lastCell = selectedCells[selectedCells.length - 1];

            // Only allow selection of adjacent cells in a straight line from the first cell
            const dir = getDirection(firstCell, newCell);
            if (!dir) return; // Must be in a straight line from the start

            // Check if all cells in between the first and newCell (inclusive) are selectable
            const potentialCells = getCellsInLine(firstCell, newCell);
            if (potentialCells.some(c => c.classList.contains('found-text'))) {
                return; // Cannot select through already found words
            }

            // Clear previous selection and re-select the new straight line
            selectedCells.forEach(c => c.classList.remove('selected-temp'));
            selectedCells = [];
            potentialCells.forEach(c => selectCell(c));
        }


        function endSelection() {
            if (!isMouseDown) return;
            isMouseDown = false;

            if (selectedCells.length < 2) { // Need at least 2 cells to form a line/word segment
                clearSelection();
                return;
            }

            const selectedWord = selectedCells.map(cell => cell.textContent).join('');
            checkWord(selectedWord);
            
            if (!selectedCells[0].classList.contains('found-text')) {
                // Clear temporary selection if the word wasn't found
                clearSelection();
            }
        }

        function selectCell(cell) {
            if (!cell.classList.contains('selected-temp')) {
                cell.classList.add('selected-temp');
                selectedCells.push(cell);
            }
        }

        function clearSelection() {
            selectedCells.forEach(cell => cell.classList.remove('selected-temp'));
            selectedCells = [];
        }

        function getDirection(cell1, cell2) {
            const r1 = parseInt(cell1.dataset.row);
            const c1 = parseInt(cell1.dataset.col);
            const r2 = parseInt(cell2.dataset.row);
            const c2 = parseInt(cell2.dataset.col);

            const dR = r2 - r1;
            const dC = c2 - c1;

            const dirR = Math.sign(dR);
            const dirC = Math.sign(dC);

            // Only allow true straight lines (horizontal, vertical, or diagonal)
            if ((dR === 0 && dC !== 0) || // Horizontal
                (dC === 0 && dR !== 0) || // Vertical
                (Math.abs(dR) === Math.abs(dC) && dR !== 0)) // Diagonal
            {
                return { row: dirR, col: dirC };
            }
            return null; // Not a straight line
        }

        // Returns an array of cell DOM elements in a straight line from startCell to endCell
        function getCellsInLine(startCell, endCell) {
            const r1 = parseInt(startCell.dataset.row);
            const c1 = parseInt(startCell.dataset.col);
            const r2 = parseInt(endCell.dataset.row);
            const c2 = parseInt(endCell.dataset.col);

            const dir = getDirection(startCell, endCell);
            if (!dir) return []; // Not a straight line

            const cellsInLine = [];
            let currR = r1;
            let currC = c1;

            // Traverse the grid cells along the detected direction
            while (true) {
                const cell = gridElement.querySelector(`[data-row="${currR}"][data-col="${currC}"]`);
                if (cell) {
                    cellsInLine.push(cell);
                }

                if (currR === r2 && currC === c2) break; // Reached the end cell

                // Move to the next cell in the direction
                currR += dir.row;
                currC += dir.col;
            }
            return cellsInLine;
        }


        function checkWord(selectedWord) {
            let foundMatch = null;
            
            wordPairs.forEach((pair, index) => {
                if (pair.found) return; // Skip already found words

                const forwardMatch = pair.foreign === selectedWord;
                const reversedSelectedWord = selectedWord.split('').reverse().join('');
                const reversedMatch = pair.foreign === reversedSelectedWord;

                if (forwardMatch || reversedMatch) {
                    foundMatch = { pair: pair, index: index, reversed: reversedMatch };
                }
            });

            if (foundMatch) {
                const { pair, index } = foundMatch;
                pair.found = true;
                foundCount++;

                // Mark grid cells as part of a found word
                selectedCells.forEach(cell => {
                    cell.classList.remove('selected-temp');
                    cell.classList.add('found-text');
                });
                
                // Store actual cells for redrawing (if needed on resize)
                pair.startCell = selectedCells[0];
                pair.endCell = selectedCells[selectedCells.length - 1];

                // Draw the line on the canvas
                drawLineForFoundWord(pair.startCell, pair.endCell);

                // Update word list item
                document.getElementById(`word-item-${index}`).classList.add('found');
                messageElement.textContent = `Found: ${pair.english}! (The French word was ${pair.foreign})`;

                if (foundCount === wordPairs.length) {
                    messageElement.textContent = "üéâ Congratulations! You found all the words! üéâ";
                }
            } else {
                messageElement.textContent = "Not a match. Try again!";
            }
        }

        // --- Canvas Drawing Functions ---

        function drawLineForFoundWord(startCell, endCell) {
            if (!startCell || !endCell) return;

            const startR = parseInt(startCell.dataset.row);
            const startC = parseInt(startCell.dataset.col);
            const endR = parseInt(endCell.dataset.row);
            const endC = parseInt(endCell.dataset.col);

            // Calculate center points of start and end cells
            const startX = (startC + 0.5) * cellWidth;
            const startY = (startR + 0.5) * cellHeight;
            const endX = (endC + 0.5) * cellWidth;
            const endY = (endR + 0.5) * cellHeight;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#2ecc71'; // Green color for found words
            ctx.lineWidth = 15; // Thick line
            ctx.lineCap = 'round'; // Rounded ends
            ctx.stroke();
        }

        function drawFoundWordsOnCanvas() {
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); // Clear existing drawings
            wordPairs.forEach(pair => {
                if (pair.found && pair.startCell && pair.endCell) {
                    drawLineForFoundWord(pair.startCell, pair.endCell);
                }
            });
        }


        // --- Start the game ---
        loadWords();

    </script>
</body>
</html>
