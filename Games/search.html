<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search - Language Practice</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Nunito&display=swap" rel="stylesheet" />
    <style>
        /* --- General and Layout Styles --- */
        body {
            font-family: 'Nunito', Arial, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }
        h1 {
            width: 100%;
            text-align: center;
            color: #3498db; /* Primary header color */
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        /* --- Grid Styles --- */
        #wordSearchGrid {
            display: grid;
            flex: 1 1 500px; /* Gives the grid more space */
            max-width: 500px; 
            margin: 0 auto; /* Center the grid */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .grid-cell {
            /* Sizing and typography */
            width: 100%;
            height: 100%;
            min-height: 30px; /* Minimum height for better tap target */
            text-align: center;
            line-height: 1.5em; /* Adjusted by JS for cell size */
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            
            /* Appearance and interaction */
            background-color: #fff;
            border: 1px solid #ddd;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s, color 0.1s;
        }
        .grid-cell:hover:not(.found) {
            background-color: #f0f0f0;
        }
        .grid-cell.selected {
            background-color: #ffeaa7; /* Soft yellow for selection */
            color: #333;
        }
        .grid-cell.found {
            background-color: #2ecc71; /* Green for found words */
            color: white;
            cursor: default;
        }

        /* --- Word List Styles (Right side) --- */
        #wordList {
            flex: 1 1 350px;
            padding: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
        }
        #wordList h2 {
            margin-top: 0;
            color: #3498db; /* Match header color */
            font-size: 1.8em;
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
        }
        .word-item {
            padding: 8px 0;
            font-size: 1.2em;
            color: #555;
            transition: all 0.3s;
        }
        .word-item.found {
            text-decoration: line-through;
            color: #95a5a6; /* Greyed out */
            font-style: italic;
            opacity: 0.7;
        }

        /* --- Message Styles --- */
        #message {
            width: 100%;
            text-align: center;
            margin-top: 20px;
            font-size: 1.4em;
            font-weight: bold;
            color: #e74c3c;
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 800px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            #wordSearchGrid {
                order: 1;
                max-width: 100%;
            }
            #wordList {
                order: 2;
                width: 100%;
                margin-top: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Word Search</h1>
        <div id="wordSearchGrid">Loading...</div>
        <div id="wordList">
            <h2>Words to Find (English):</h2>
            <div id="translationList">Awaiting data...</div>
        </div>
        <div id="message"></div>
    </div>

    <script>
        // --- Configuration ---
        const GRID_SIZE = 15; // 15x15 grid
        const MAX_WORDS = 10; // Max number of words to place from the spreadsheet
        const foreignColumn = 1; // Column B (index 1)
        const englishColumn = 2; // Column C (index 2)

        // --- Game State ---
        let wordPairs = []; // [{foreign: "Mots", english: "Words", found: false}]
        let grid = [];
        let selectedCells = [];
        let isMouseDown = false;
        let foundCount = 0;

        // --- DOM Elements ---
        const gridElement = document.getElementById('wordSearchGrid');
        const translationListElement = document.getElementById('translationList');
        const messageElement = document.getElementById('message');
        const params = new URLSearchParams(window.location.search);
        const sheetUrl = params.get('sheet');

        // --- Data Loading and Initialization ---

        function loadWords() {
            if (!sheetUrl) {
                messageElement.textContent = "⚠️ Error: No CSV URL provided in the 'sheet' parameter.";
                return;
            }

            Papa.parse(sheetUrl, {
                download: true,
                header: false,
                skipEmptyLines: true,
                complete: function (results) {
                    const data = results.data.slice(1); // Skip header row
                    let availableWords = data
                        .map(row => ({
                            // Clean foreign word: uppercase and remove non-alphabetic/non-accented characters
                            foreign: row[foreignColumn] ? row[foreignColumn].trim().toUpperCase().replace(/[^A-ZÀÂÄÉÈÊËÎÏÔÖÙÛÜÇ]/g, '') : '',
                            english: row[englishColumn] ? row[englishColumn].trim() : ''
                        }))
                        .filter(pair => pair.foreign.length >= 3 && pair.foreign.length <= GRID_SIZE);

                    // Select a maximum number of words
                    wordPairs = availableWords.slice(0, MAX_WORDS).map(pair => ({
                        ...pair,
                        found: false
                    }));

                    if (wordPairs.length === 0) {
                        messageElement.textContent = "⚠️ No suitable words found in the spreadsheet.";
                        return;
                    }

                    initializeGame();
                },
                error: function (err) {
                    messageElement.textContent = "⚠️ Error loading the CSV file: " + err.message;
                    console.error(err);
                }
            });
        }

        // --- Word Search Grid Logic ---

        const directions = [
            { row: 0, col: 1 },    // Horizontal (right)
            { row: 1, col: 0 },    // Vertical (down)
            { row: 1, col: 1 },    // Diagonal (down-right)
            { row: 1, col: -1 },   // Diagonal (down-left)
            { row: 0, col: -1 },   // Horizontal (left) <-- Added reverse directions
            { row: -1, col: 0 },   // Vertical (up)
            { row: -1, col: -1 },  // Diagonal (up-left)
            { row: -1, col: 1 },   // Diagonal (up-right)
        ];

        function initializeGrid() {
            // 1. Setup empty grid and styles
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
            
            // Set grid template for proper cell sizing
            gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            gridElement.innerHTML = '';
            
            // 2. Attempt to place words
            let placedWords = [];
            
            // Sort words by length descending to help placement
            wordPairs.sort((a, b) => b.foreign.length - a.foreign.length).forEach(wordPair => {
                const word = wordPair.foreign;
                let success = false;
                
                // Try placement up to 100 times
                for (let attempt = 0; attempt < 100; attempt++) {
                    const row = Math.floor(Math.random() * GRID_SIZE);
                    const col = Math.floor(Math.random() * GRID_SIZE);
                    const dirIndex = Math.floor(Math.random() * directions.length);
                    const dir = directions[dirIndex];

                    if (canPlaceWord(word, row, col, dir)) {
                        placeWord(word, row, col, dir);
                        placedWords.push(wordPair);
                        success = true;
                        break;
                    }
                }
                if (!success) {
                    console.warn(`Could not place word: ${word}`);
                }
            });

            wordPairs = placedWords; // Only keep words that were successfully placed

            // 3. Fill remaining empty cells with random letters
            const fillerLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZÀÂÄÉÈÊËÎÏÔÖÙÛÜÇ";
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === null) {
                        const randomLetter = fillerLetters[Math.floor(Math.random() * fillerLetters.length)];
                        grid[r][c] = randomLetter;
                    }
                }
            }

            // 4. Render the grid
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.textContent = grid[r][c];
                    gridElement.appendChild(cell);
                }
            }
            
            // Calculate and set the line-height for cells to ensure text is centered vertically
            // This must run AFTER cells are added to the DOM and the CSS has sized them.
            if (gridElement.firstChild) {
                const cellHeight = gridElement.firstChild.clientHeight;
                document.querySelectorAll('.grid-cell').forEach(cell => {
                    cell.style.lineHeight = `${cellHeight}px`;
                });
            }
        }

        function canPlaceWord(word, startRow, startCol, dir) {
            for (let i = 0; i < word.length; i++) {
                const r = startRow + i * dir.row;
                const c = startCol + i * dir.col;

                if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) {
                    return false; // Out of bounds
                }
                if (grid[r][c] !== null && grid[r][c] !== word[i]) {
                    return false; // Conflict with existing letter
                }
            }
            return true;
        }

        function placeWord(word, startRow, startCol, dir) {
            for (let i = 0; i < word.length; i++) {
                const r = startRow + i * dir.row;
                const c = startCol + i * dir.col;
                grid[r][c] = word[i];
            }
        }

        // --- Word List Rendering ---

        function renderWordList() {
            translationListElement.innerHTML = '';
            wordPairs.forEach((pair, index) => {
                const item = document.createElement('div');
                item.className = `word-item ${pair.found ? 'found' : ''}`;
                item.id = `word-item-${index}`;
                // Display English translation to be found
                item.textContent = pair.english; 
                translationListElement.appendChild(item);
            });
        }

        // --- Selection and Validation Logic ---

        function initializeGame() {
            initializeGrid();
            renderWordList();
            setupSelectionListeners();
        }

        function setupSelectionListeners() {
            // Use touch events for mobile compatibility
            gridElement.addEventListener('mousedown', startSelection);
            gridElement.addEventListener('mouseup', endSelection);
            document.addEventListener('mouseup', endSelection); 
            gridElement.addEventListener('mouseover', moveSelection);

            gridElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startSelection({ target: e.target, clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
            }, { passive: false });
            gridElement.addEventListener('touchend', endSelection);
            gridElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.classList.contains('grid-cell')) {
                    moveSelection({ target: target });
                }
            }, { passive: false });
        }

        function startSelection(e) {
            if (!e.target.classList.contains('grid-cell') || e.target.classList.contains('found')) return;

            isMouseDown = true;
            clearSelection();
            selectCell(e.target);
        }

        function moveSelection(e) {
            if (!isMouseDown || !e.target.classList.contains('grid-cell')) return;

            const newCell = e.target;
            
            if (selectedCells.length === 0) {
                selectCell(newCell);
            } else if (selectedCells.length === 1) {
                // If only one cell is selected, allow the second cell to establish the direction
                selectCell(newCell);
            } else if (selectedCells.length >= 2) {
                const lastCell = selectedCells[selectedCells.length - 1];
                
                // Get the direction established by the first two cells
                const dir = getDirection(selectedCells[0], selectedCells[1]);
                if (!dir) return;

                // Determine the expected next cell
                const expectedR = parseInt(lastCell.dataset.row) + dir.row;
                const expectedC = parseInt(lastCell.dataset.col) + dir.col;
                const currentR = parseInt(newCell.dataset.row);
                const currentC = parseInt(newCell.dataset.col);

                // Check if the new cell is the next cell in the established straight line
                if (currentR === expectedR && currentC === expectedC) {
                    selectCell(newCell);
                } else if (newCell === selectedCells[selectedCells.length - 2]) {
                    // Allows going back one step to refine selection
                    lastCell.classList.remove('selected');
                    selectedCells.pop();
                }
            }
        }

        function endSelection() {
            if (!isMouseDown) return;
            isMouseDown = false;

            if (selectedCells.length < 3) { 
                clearSelection();
                return;
            }

            const selectedWord = selectedCells.map(cell => cell.textContent).join('');
            checkWord(selectedWord);
            
            if (!selectedCells[0].classList.contains('found')) {
                // Clear selection if the word wasn't found
                clearSelection();
            }
        }

        function selectCell(cell) {
            if (selectedCells.includes(cell)) return;

            cell.classList.add('selected');
            selectedCells.push(cell);
        }

        function clearSelection() {
            selectedCells.forEach(cell => cell.classList.remove('selected'));
            selectedCells = [];
        }

        function getDirection(cell1, cell2) {
            const r1 = parseInt(cell1.dataset.row);
            const c1 = parseInt(cell1.dataset.col);
            const r2 = parseInt(cell2.dataset.row);
            const c2 = parseInt(cell2.dataset.col);

            const dR = r2 - r1;
            const dC = c2 - c1;

            // Normalize differences to -1, 0, or 1
            const dirR = Math.sign(dR);
            const dirC = Math.sign(dC);

            // Check if it's a straight line (horizontal, vertical, or diagonal)
            if (Math.abs(dR) === 0 && Math.abs(dC) > 0 || // Horizontal
                Math.abs(dC) === 0 && Math.abs(dR) > 0 || // Vertical
                Math.abs(dR) === Math.abs(dC) && Math.abs(dR) > 0) // Diagonal
            {
                return { row: dirR, col: dirC };
            }

            return null; // Not a straight line
        }

        function checkWord(selectedWord) {
            
            let foundIndex = -1;
            
            wordPairs.forEach((pair, index) => {
                // Check if the selected word (forward or reversed) matches the foreign word
                const forwardMatch = pair.foreign === selectedWord;
                const reversedMatch = pair.foreign === selectedWord.split('').reverse().join('');

                if ((forwardMatch || reversedMatch) && !pair.found) {
                    foundIndex = index;
                }
            });

            if (foundIndex !== -1) {
                wordPairs[foundIndex].found = true;
                foundCount++;

                // Apply "found" class to cells
                selectedCells.forEach(cell => {
                    cell.classList.remove('selected');
                    cell.classList.add('found');
                });

                // Update word list
                document.getElementById(`word-item-${foundIndex}`).classList.add('found');
                messageElement.textContent = `Found: ${wordPairs[foundIndex].english}! (The French word was ${wordPairs[foundIndex].foreign})`;

                if (foundCount === wordPairs.length) {
                    messageElement.textContent = "🎉 Congratulations! You found all the words! 🎉";
                }
            } else {
                messageElement.textContent = "Not a match. Try again!";
            }
        }

        // --- Start the game ---
        loadWords();

    </script>
</body>
</html>
