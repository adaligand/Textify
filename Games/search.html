<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search - Language Practice</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Nunito&display=swap" rel="stylesheet" />
    <style>
        /* --- General and Layout Styles --- */
        body {
            font-family: 'Nunito', Arial, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .game-container {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }
        h1 {
            width: 100%;
            text-align: center;
            color: #3498db; 
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        /* --- Grid & Overlay Container --- */
        #grid-and-overlay-container {
            position: relative;
            flex: 1 1 600px; 
            max-width: 600px; 
            margin: 0 auto;
            aspect-ratio: 1 / 1; 
            border: 2px solid #ccc; 
            border-radius: 5px;
        }

        /* --- Grid Letters --- */
        #wordSearchGrid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            z-index: 3; /* Letters layer is on top of the drawing canvas */
            /* IMPORTANT: We MUST allow pointer events here to capture the click on the letters */
            pointer-events: auto; 
        }
        .grid-cell {
            display: flex; 
            justify-content: center;
            align-items: center;
            font-size: 1.6em; 
            font-weight: bold;
            color: #333;
            background-color: transparent;
            border: none;
            cursor: pointer;
            user-select: none;
        }
        
        /* --- Canvas Overlay for Drawing Lines --- */
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Drawing layer is behind the letters */
            pointer-events: none; /* Crucial: Mouse/touch events pass through to the grid cells below */
        }
        
        /* --- Word List Styles (Right side) --- */
        #wordList {
            flex: 1 1 300px; 
            padding: 10px 15px; 
            background-color: white; 
            border-radius: 10px;
        }
        .word-item-wrapper {
            margin-bottom: 8px;
        }
        .word-item {
            display: inline-block; 
            padding: 8px 12px;
            font-size: 1.1em;
            color: #555;
            background-color: #ecf0f1; 
            border-radius: 8px; 
            transition: all 0.3s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .word-item.found {
            text-decoration: none; 
            color: white;
            background-color: #2ecc71; 
            font-style: normal;
            opacity: 1;
            box-shadow: 0 2px 5px rgba(46, 204, 113, 0.3); 
        }

        /* --- Message Styles --- */
        #message {
            width: 100%;
            text-align: center;
            margin-top: 20px;
            font-size: 1.4em;
            font-weight: bold;
            color: #e74c3c;
        }

        /* --- Responsive Adjustments (Omitted for brevity, unchanged) --- */
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Word Search</h1>
        <div id="grid-and-overlay-container">
            <div id="wordSearchGrid">Loading...</div>
            <canvas id="drawingCanvas"></canvas>
        </div>
        <div id="wordList">
            <div id="translationList">Awaiting data...</div>
        </div>
        <div id="message"></div>
    </div>

    <script>
        // --- Configuration ---
        const GRID_SIZE = 15; 
        const MAX_WORDS = 10; 
        const foreignColumn = 1; 
        const englishColumn = 2; 

        // --- Game State ---
        let wordPairs = []; 
        let grid = [];
        let selectedCells = []; 
        let isMouseDown = false;
        let foundCount = 0;

        // --- DOM Elements ---
        const gridAndOverlayContainer = document.getElementById('grid-and-overlay-container');
        const gridElement = document.getElementById('wordSearchGrid');
        const translationListElement = document.getElementById('translationList');
        const messageElement = document.getElementById('message');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const ctx = drawingCanvas.getContext('2d');

        const params = new URLSearchParams(window.location.search);
        const sheetUrl = params.get('sheet');

        let cellWidth = 0; 
        let cellHeight = 0;

        // --- Data Loading and Initialization (Unchanged) ---
        function loadWords() {
            if (!sheetUrl) {
                messageElement.textContent = "‚ö†Ô∏è Error: No CSV URL provided in the 'sheet' parameter.";
                return;
            }

            Papa.parse(sheetUrl, {
                download: true,
                header: false,
                skipEmptyLines: true,
                complete: function (results) {
                    const data = results.data.slice(1); 
                    let availableWords = data
                        .map(row => ({
                            foreign: row[foreignColumn] ? row[foreignColumn].trim().toUpperCase().replace(/[^A-Z√Ä√Ç√Ñ√â√à√ä√ã√é√è√î√ñ√ô√õ√ú√á]/g, '') : '',
                            english: row[englishColumn] ? row[englishColumn].trim() : ''
                        }))
                        .filter(pair => pair.foreign.length >= 3 && pair.foreign.length <= GRID_SIZE);

                    wordPairs = availableWords.slice(0, MAX_WORDS).map(pair => ({
                        ...pair,
                        found: false,
                        startCell: null,
                        endCell: null
                    }));

                    if (wordPairs.length === 0) {
                        messageElement.textContent = "‚ö†Ô∏è No suitable words found in the spreadsheet.";
                        return;
                    }

                    initializeGame();
                },
                error: function (err) {
                    messageElement.textContent = "‚ö†Ô∏è Error loading the CSV file: " + err.message;
                    console.error(err);
                }
            });
        }
        
        const directions = [
            { row: 0, col: 1 }, { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 1, col: -1 }, 
            { row: 0, col: -1 }, { row: -1, col: 0 }, { row: -1, col: -1 }, { row: -1, col: 1 }
        ];

        function initializeGrid() {
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
            gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            gridElement.innerHTML = '';
            
            let placedWordsDetails = []; 
            wordPairs.sort(() => Math.random() - 0.5);

            wordPairs.forEach(wordPair => {
                const word = wordPair.foreign;
                let success = false;
                
                for (let attempt = 0; attempt < 200; attempt++) {
                    const startRow = Math.floor(Math.random() * GRID_SIZE);
                    const startCol = Math.floor(Math.random() * GRID_SIZE);
                    const dirIndex = Math.floor(Math.random() * directions.length);
                    const dir = directions[dirIndex];

                    if (canPlaceWord(word, startRow, startCol, dir)) {
                        placeWord(word, startRow, startCol, dir);
                        placedWordsDetails.push({
                            word: word,
                            start: { row: startRow, col: startCol },
                            end: { row: startRow + (word.length - 1) * dir.row, col: startCol + (word.length - 1) * dir.col }
                        });
                        success = true;
                        break;
                    }
                }
            });

            wordPairs = wordPairs.filter(pair => placedWordsDetails.some(pd => pd.word === pair.foreign));
            wordPairs.forEach(pair => {
                const details = placedWordsDetails.find(pd => pd.word === pair.foreign);
                if (details) {
                    pair.startCoords = details.start;
                    pair.endCoords = details.end;
                }
            });

            const fillerLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Ç√Ñ√â√à√ä√ã√é√è√î√ñ√ô√õ√ú√á";
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === null) {
                        const randomLetter = fillerLetters[Math.floor(Math.random() * fillerLetters.length)];
                        grid[r][c] = randomLetter;
                    }
                }
            }

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.textContent = grid[r][c];
                    gridElement.appendChild(cell);
                }
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const containerRect = gridAndOverlayContainer.getBoundingClientRect();
            drawingCanvas.width = containerRect.width;
            drawingCanvas.height = containerRect.height;
            
            cellWidth = containerRect.width / GRID_SIZE;
            cellHeight = containerRect.height / GRID_SIZE;

            if (foundCount > 0) {
                drawFoundWordsOnCanvas();
            }
        }

        function canPlaceWord(word, startRow, startCol, dir) {
            for (let i = 0; i < word.length; i++) {
                const r = startRow + i * dir.row;
                const c = startCol + i * dir.col;
                if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || (grid[r][c] !== null && grid[r][c] !== word[i])) {
                    return false;
                }
            }
            return true;
        }

        function placeWord(word, startRow, startCol, dir) {
            for (let i = 0; i < word.length; i++) {
                grid[startRow + i * dir.row][startCol + i * dir.col] = word[i];
            }
        }
        
        function renderWordList() {
            translationListElement.innerHTML = '';
            wordPairs.forEach((pair, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'word-item-wrapper';

                const item = document.createElement('span');
                item.className = `word-item ${pair.found ? 'found' : ''}`;
                item.id = `word-item-${index}`;
                item.textContent = pair.english; 
                wrapper.appendChild(item);
                translationListElement.appendChild(wrapper);
            });
        }

        // --- Selection and Validation Logic ---

        function initializeGame() {
            initializeGrid();
            renderWordList();
            setupSelectionListeners();
        }

        function setupSelectionListeners() {
            // Mouse events
            // We listen on the gridElement (the letters layer)
            gridElement.addEventListener('mousedown', startSelection);
            document.addEventListener('mouseup', endSelection); 
            gridElement.addEventListener('mousemove', moveSelection);

            // Touch events
            gridElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startSelection({ target: e.target });
            }, { passive: false });
            gridElement.addEventListener('touchend', endSelection);
            gridElement.addEventListener('touchcancel', endSelection);
            gridElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                // Determine the element under the touch point
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.closest('.grid-cell')) {
                    moveSelection({ target: target });
                }
            }, { passive: false });
        }

        function getCellFromEventTarget(target) {
            return target.closest('.grid-cell');
        }

        function startSelection(e) {
            const cell = getCellFromEventTarget(e.target);
            if (!cell) return; // Must start on a letter cell

            if (cell.classList.contains('found-text')) return;

            isMouseDown = true;
            clearSelection();
            messageElement.textContent = ""; 
            selectedCells.push(cell);
            // Draw initial selection line (a dot)
            drawSelectionLine(selectedCells[0], selectedCells[0]);
        }

        function moveSelection(e) {
            if (!isMouseDown) return;

            const newCell = getCellFromEventTarget(e.target);
            if (!newCell) return; 

            const firstCell = selectedCells[0];
            
            // Check if the new cell is in a straight line from the start cell
            const dir = getDirection(firstCell, newCell);
            if (!dir && selectedCells.length > 1) return; // Must follow a straight line after the first cell

            // If moving back over a previously selected cell, shorten the line
            if (selectedCells.length >= 2 && newCell === selectedCells[selectedCells.length - 2]) {
                selectedCells.pop();
            } else if (!selectedCells.includes(newCell)) {
                // If it's a new cell, update the entire selection to be the straight line
                const potentialCells = getCellsInLine(firstCell, newCell);
                if (potentialCells.some(c => c.classList.contains('found-text'))) {
                    return; // Cannot select through already found words
                }

                selectedCells = potentialCells;
            }

            // Redraw the line to the current endpoint
            if (selectedCells.length > 0) {
                 drawSelectionLine(selectedCells[0], selectedCells[selectedCells.length - 1]);
            } else {
                 drawFoundWordsOnCanvas(); // Only permanent lines remain
            }
           
        }


        function endSelection() {
            if (!isMouseDown) return;
            isMouseDown = false;

            if (selectedCells.length < 3) { 
                clearSelection();
                return;
            }

            const selectedWord = selectedCells.map(cell => cell.textContent).join('');
            checkWord(selectedWord);
            
            if (!selectedCells[0].classList.contains('found-text')) {
                // Clear the temporary canvas line if the word wasn't found
                clearSelection();
            }
        }

        function clearSelection() {
            // Clear the temporary selection line from the canvas
            drawFoundWordsOnCanvas(); // Redraw only the permanent lines
            selectedCells = [];
        }

        function getDirection(cell1, cell2) {
            const r1 = parseInt(cell1.dataset.row);
            const c1 = parseInt(cell1.dataset.col);
            const r2 = parseInt(cell2.dataset.row);
            const c2 = parseInt(cell2.dataset.col);

            const dR = r2 - r1;
            const dC = c2 - c1;

            const dirR = Math.sign(dR);
            const dirC = Math.sign(dC);

            if ((dR === 0 && dC !== 0) || (dC === 0 && dR !== 0) || (Math.abs(dR) === Math.abs(dC) && dR !== 0)) {
                return { row: dirR, col: dirC };
            }
            return null; 
        }

        function getCellsInLine(startCell, endCell) {
            const r1 = parseInt(startCell.dataset.row);
            const c1 = parseInt(startCell.dataset.col);
            const r2 = parseInt(endCell.dataset.row);
            const c2 = parseInt(endCell.dataset.col);

            const dir = getDirection(startCell, endCell);
            if (!dir) return []; 

            const cellsInLine = [];
            let currR = r1;
            let currC = c1;

            while (true) {
                const cell = gridElement.querySelector(`[data-row="${currR}"][data-col="${currC}"]`);
                if (cell) {
                    cellsInLine.push(cell);
                }

                if (currR === r2 && currC === c2) break; 

                currR += dir.row;
                currC += dir.col;
            }
            return cellsInLine;
        }


        function checkWord(selectedWord) {
            let foundMatch = null;
            
            wordPairs.forEach((pair, index) => {
                if (pair.found) return; 

                const forwardMatch = pair.foreign === selectedWord;
                const reversedSelectedWord = selectedWord.split('').reverse().join('');
                const reversedMatch = pair.foreign === reversedSelectedWord;

                if (forwardMatch || reversedMatch) {
                    foundMatch = { pair: pair, index: index };
                }
            });

            if (foundMatch) {
                const { pair, index } = foundMatch;
                pair.found = true;
                foundCount++;

                // Mark grid cells (for validation purposes, though no visible styling is applied)
                selectedCells.forEach(cell => {
                    cell.classList.add('found-text');
                });
                
                // Store actual cells for redrawing 
                pair.startCell = selectedCells[0];
                pair.endCell = selectedCells[selectedCells.length - 1];

                // Draw the permanent green line on the canvas and clear the temporary red line
                drawFoundWordsOnCanvas();

                // Update word list item
                document.getElementById(`word-item-${index}`).classList.add('found');
                messageElement.textContent = `Found: ${pair.english}! (The foreign word was ${pair.foreign})`;

                if (foundCount === wordPairs.length) {
                    messageElement.textContent = "üéâ Congratulations! You found all the words! üéâ";
                }
            } else {
                messageElement.textContent = "Not a match. Try again!";
            }
        }

        // --- Canvas Drawing Functions ---
        
        function getCellCenter(cell) {
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);
            return {
                x: (c + 0.5) * cellWidth,
                y: (r + 0.5) * cellHeight
            };
        }

        function drawSelectionLine(startCell, endCell) {
            // Clear temporary red line by redrawing the permanent green lines first
            drawFoundWordsOnCanvas(); 
            
            if (!startCell || !endCell) return;

            const startCoords = getCellCenter(startCell);
            const endCoords = getCellCenter(endCell);

            ctx.beginPath();
            ctx.moveTo(startCoords.x, startCoords.y);
            ctx.lineTo(endCoords.x, endCoords.y);
            ctx.strokeStyle = '#e74c3c'; // Red/Orange for temporary selection
            ctx.lineWidth = 10; 
            ctx.lineCap = 'round';
            ctx.stroke();
        }


        function drawLineForFoundWord(startCell, endCell) {
            if (!startCell || !endCell) return;

            const startCoords = getCellCenter(startCell);
            const endCoords = getCellCenter(endCell);

            ctx.beginPath();
            ctx.moveTo(startCoords.x, startCoords.y);
            ctx.lineTo(endCoords.x, endCoords.y);
            ctx.strokeStyle = '#2ecc71'; // Green for found words
            ctx.lineWidth = 15; 
            ctx.lineCap = 'round'; 
            ctx.stroke();
        }

        function drawFoundWordsOnCanvas() {
            // Clear the entire canvas first
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); 

            // Redraw only the permanent green lines
            wordPairs.forEach(pair => {
                if (pair.found && pair.startCell && pair.endCell) {
                    drawLineForFoundWord(pair.startCell, pair.endCell);
                }
            });
        }


        // --- Start the game ---
        loadWords();

    </script>
</body>
</html>
